<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spaghetti.network &#8212; spaghetti v1.7.6 Manual</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css?v=9afac83c" />
    <link rel="stylesheet" type="text/css" href="../../_static/pysal-styles.css?v=4849bb1c" />
    <script src="../../_static/documentation_options.js?v=6cfcd222"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="icon" href="../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          spaghetti</a>
        <span class="navbar-text navbar-version pull-left"><b>1.7.6</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../installation.html">Installation</a></li>
                <li><a href="../../tutorials.html">Tutorials</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-with-conda-via-spaghetti-feedstock-highly-recommended">Installing with <code class="docutils literal notranslate"><span class="pre">conda</span></code> via spaghetti-feedstock (highly recommended)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-with-python-package-index">Installing with Python Package Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#development-version">Development Version</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/quickstart.html">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/pointpattern-attributes.html">Network point pattern attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/connected-components.html">Connected components in a spatial network</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/shortest-path-visualization.html">Generating regular lattices and visualizing shortest paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/network-segmentation.html">Spatial network segmentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/network-spatial-dependence.html">Network-constrained spatial dependence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/network-spatial-weights.html">Network spatial weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/spanning-trees.html">Network spanning trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/caveats.html">Caveats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/network-spatial-autocorrelation.html">Network-constrained spatial autocorrelation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/facility-location.html">Demostrating network-based optimal facility location modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/transportation-problem.html">The Transportation Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/tsp.html">The Traveling Sales(man)(person) Problem â€” TSP</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#network-feature-instantiation">Network feature instantiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#network-feature-extraction-and-creation">Network feature extraction and creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#save-and-load-a-network">Save and load a network</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for spaghetti.network</h1><div class="highlight"><pre>
<span></span><span class="c1"># ruff: noqa: B009</span>

<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

<span class="kn">import</span> <span class="nn">esda</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">libpysal</span> <span class="kn">import</span> <span class="n">cg</span><span class="p">,</span> <span class="n">weights</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.analysis</span> <span class="kn">import</span> <span class="n">GlobalAutoK</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">libpysal</span> <span class="kn">import</span> <span class="nb">open</span> <span class="k">as</span> <span class="n">_open</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">libpysal</span>

    <span class="n">_open</span> <span class="o">=</span> <span class="n">libpysal</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Network&quot;</span><span class="p">,</span> <span class="s2">&quot;PointPattern&quot;</span><span class="p">,</span> <span class="s2">&quot;GlobalAutoK&quot;</span><span class="p">]</span>

<span class="n">SAME_SEGMENT</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">)</span>


<span class="n">dep_msg</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;The next major release of pysal/spaghetti (2.0.0) will &quot;</span>
    <span class="s2">&quot;drop support for all ``libpysal.cg`` geometries. This change &quot;</span>
    <span class="s2">&quot;is a first step in refactoring ``spaghetti`` that is &quot;</span>
    <span class="s2">&quot;expected to result in dramatically reduced runtimes for &quot;</span>
    <span class="s2">&quot;network instantiation and operations. Users currently &quot;</span>
    <span class="s2">&quot;requiring network and point pattern input as ``libpysal.cg`` &quot;</span>
    <span class="s2">&quot;geometries should prepare for this simply by converting &quot;</span>
    <span class="s2">&quot;to ``shapely`` geometries.&quot;</span>
<span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">dep_msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="Network">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network">[docs]</a>
<span class="k">class</span> <span class="nc">Network</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spatially-constrained network representation and analytical</span>
<span class="sd">    functionality. Naming conventions are as follows, (1) arcs and</span>
<span class="sd">    vertices for the full network object, and (2) edges and nodes for</span>
<span class="sd">    the simplified graph-theoretic object. The term &#39;link&#39; is used to</span>
<span class="sd">    refer to a network arc or a graph edge.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_data : {str, iterable, libpysal.cg.Chain, geopandas.GeoDataFrame}</span>
<span class="sd">        The input geographic data. Either (1) a path to a shapefile</span>
<span class="sd">        (str); (2) an iterable containing ``libpysal.cg.Chain``</span>
<span class="sd">        objects; (3) a single ``libpysal.cg.Chain``; or</span>
<span class="sd">        (4) a ``geopandas.GeoDataFrame``.</span>
<span class="sd">    vertex_sig : int</span>
<span class="sd">        Round the x and y coordinates of all vertices to ``vertex_sig``</span>
<span class="sd">        significant digits (combined significant digits on the left and</span>
<span class="sd">        right of the decimal place). Default is 11. Set to ``None`` for</span>
<span class="sd">        no rounding.</span>
<span class="sd">    unique_arcs : bool</span>
<span class="sd">        If ``True`` (default), keep only unique arcs (i.e., prune</span>
<span class="sd">        out any duplicated arcs). If ``False`` keep all segments.</span>
<span class="sd">    extractgraph : bool</span>
<span class="sd">        If ``True``, extract a graph-theoretic object with no degree 2</span>
<span class="sd">        nodes. Default is ``True``.</span>
<span class="sd">    w_components : bool</span>
<span class="sd">        Set to ``False`` to not record connected components from a</span>
<span class="sd">        ``libpysal.weights.W`` object. Default is ``True``.</span>
<span class="sd">    weightings : {dict, bool}</span>
<span class="sd">        If dict, lists of weightings for each arc. If bool,</span>
<span class="sd">        ``True`` flags ``self.arc_lengths`` as the weightings,</span>
<span class="sd">        ``False`` sets no weightings. Default is ``False``.</span>
<span class="sd">    weights_kws : dict</span>
<span class="sd">        Keyword arguments for ``libpysal.weights.W``. Default is ``dict()``.</span>
<span class="sd">    vertex_atol : {int, None}</span>
<span class="sd">        Precision for vertex absolute tolerance. Round vertex coordinates to</span>
<span class="sd">        ``vertex_atol`` decimal places. Default is ``None``. **ONLY** change</span>
<span class="sd">        the default when there are known issues with digitization.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    adjacencylist : list</span>
<span class="sd">        List of lists storing vertex adjacency.</span>
<span class="sd">    vertex_coords : dict</span>
<span class="sd">        Keys are vertex IDs and values are :math:`(x,y)` coordinates of the vertices.</span>
<span class="sd">    vertex_list : list</span>
<span class="sd">        List of vertex IDs.</span>
<span class="sd">    vertices : dict</span>
<span class="sd">        Keys are tuples of vertex coords and values are the vertex ID.</span>
<span class="sd">    arcs : list</span>
<span class="sd">        List of arcs, where each arc is a sorted tuple</span>
<span class="sd">        of vertex IDs.</span>
<span class="sd">    arc_lengths : dict</span>
<span class="sd">        Keys are tuples of sorted vertex IDs representing an arc and</span>
<span class="sd">        values are the length.</span>
<span class="sd">    pointpatterns : dict</span>
<span class="sd">        Keys are a string name of the pattern and values are</span>
<span class="sd">        ``PointPattern`` class instances.</span>
<span class="sd">    distance_matrix : numpy.ndarray</span>
<span class="sd">        All network vertices (non-observations) distance matrix. Distances</span>
<span class="sd">        between vertices in disparate components are recorded as ``inf``</span>
<span class="sd">        by default.</span>
<span class="sd">    network_trees : dict</span>
<span class="sd">        Keys are the vertex IDs (``int``). Values are dictionaries</span>
<span class="sd">        with the keys being the IDs of the destination vertex</span>
<span class="sd">        and values being lists of vertices along the shortest path.</span>
<span class="sd">        If the destination vertex is a) the origin or b)</span>
<span class="sd">        unreachable (disparate component) it is listed as itself being the</span>
<span class="sd">        neighbor.</span>
<span class="sd">    edges : list</span>
<span class="sd">        Tuples of graph edge IDs.</span>
<span class="sd">    edge_lengths : dict</span>
<span class="sd">        Keys are the graph edge IDs (``tuple``). Values are the</span>
<span class="sd">        graph edge length (``float``).</span>
<span class="sd">    non_articulation_points : list</span>
<span class="sd">        All vertices with degree 2 that are not in an isolated</span>
<span class="sd">        island ring (loop) component.</span>
<span class="sd">    w_network : libpysal.weights.W</span>
<span class="sd">        Weights object created from the network arcs.</span>
<span class="sd">    network_n_components : int</span>
<span class="sd">        Count of connected components in the network.</span>
<span class="sd">    network_fully_connected : bool</span>
<span class="sd">        ``True`` if the network representation is a single connected</span>
<span class="sd">        component, otherwise ``False``.</span>
<span class="sd">    network_component_labels : numpy.ndarray</span>
<span class="sd">        Component labels for network arcs.</span>
<span class="sd">    network_component2arc : dict</span>
<span class="sd">        Lookup in the form {int: list} for arcs comprising network</span>
<span class="sd">        connected components keyed by component labels with arcs in</span>
<span class="sd">        a list as values.</span>
<span class="sd">    network_component_lengths : dict</span>
<span class="sd">        Length of each network component (keyed by component label).</span>
<span class="sd">    network_longest_component : int</span>
<span class="sd">        The ID of the longest component in the network. This is not</span>
<span class="sd">        necessarily equal to ``network_largest_component``.</span>
<span class="sd">    network_component_vertices : dict</span>
<span class="sd">        Lookup in the form {int: list} for vertices comprising network</span>
<span class="sd">        connected components keyed by component labels with vertices in</span>
<span class="sd">        a list as values.</span>
<span class="sd">    network_component_vertex_count : dict</span>
<span class="sd">        The number of vertices in each network component</span>
<span class="sd">        (keyed by component label).</span>
<span class="sd">    network_largest_component : int</span>
<span class="sd">        The ID of the largest component in the network. Within ``spaghetti``</span>
<span class="sd">        the largest component is the one with the most vertices. This is not</span>
<span class="sd">        necessarily equal to ``network_longest_component``.</span>
<span class="sd">    network_component_is_ring : dict</span>
<span class="sd">        Lookup in the form {int: bool} keyed by component labels with values</span>
<span class="sd">        as ``True`` if the component is a closed ring, otherwise ``False``.</span>
<span class="sd">    w_graph : libpysal.weights.W</span>
<span class="sd">        Weights object created from the graph edges.</span>
<span class="sd">    graph_n_components : int</span>
<span class="sd">        Count of connected components in the network.</span>
<span class="sd">    graph_fully_connected : bool</span>
<span class="sd">        ``True`` if the graph representation is a single connected</span>
<span class="sd">        component, otherwise ``False``.</span>
<span class="sd">    graph_component_labels : numpy.ndarray</span>
<span class="sd">        Component labels for graph edges.</span>
<span class="sd">    graph_component2edge : dict</span>
<span class="sd">        Lookup in the form {int: list} for edges comprising graph connected</span>
<span class="sd">        components keyed by component labels with edges in a list</span>
<span class="sd">        as values.</span>
<span class="sd">    graph_component_lengths : dict</span>
<span class="sd">        Length of each graph component (keyed by component label).</span>
<span class="sd">    graph_longest_component : int</span>
<span class="sd">        The ID of the longest component in the graph. This is not</span>
<span class="sd">        necessarily equal to ``graph_largest_component``.</span>
<span class="sd">    graph_component_vertices : dict</span>
<span class="sd">        Lookup in the form {int: list} for vertices comprising graph</span>
<span class="sd">        connected components keyed by component labels with vertices in</span>
<span class="sd">        a list as values.</span>
<span class="sd">    graph_component_vertex_count : dict</span>
<span class="sd">        The number of vertices in each graph component</span>
<span class="sd">        (keyed by component label).</span>
<span class="sd">    graph_largest_component : int</span>
<span class="sd">        The ID of the largest component in the graph. Within ``spaghetti``</span>
<span class="sd">        the largest component is the one with the most vertices. This is not</span>
<span class="sd">        necessarily equal to ``graph_longest_component``.</span>
<span class="sd">    graph_component_is_ring : dict</span>
<span class="sd">        Lookup in the form {int: bool} keyed by component labels with values as</span>
<span class="sd">        ``True`` if the component is a closed ring, otherwise ``False``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    **Important**: The core procedure for generating network representations is</span>
<span class="sd">    performed within the ``_extractnetwork()`` method. Here it is important to note</span>
<span class="sd">    that a ``spaghetti.Network`` instance is built up from the individual,</span>
<span class="sd">    constituent euclidean units of each line segment object. Therefore, the resulting</span>
<span class="sd">    network structure will generally have (1) more vertices and links than may expected,</span>
<span class="sd">    and, (2) many degree-2 vertices, which differs from a truly graph-theoretic object.</span>
<span class="sd">    This is demonstrated in the</span>
<span class="sd">    `Caveats Tutorial &lt;https://pysal.org/spaghetti/notebooks/caveats.html&gt;`_.</span>

<span class="sd">    See :cite:`Cliff1981`, :cite:`Tansel1983a`,</span>
<span class="sd">    :cite:`AhujaRavindraK`, :cite:`Labbe1995`,</span>
<span class="sd">    :cite:`Kuby2009`, :cite:`Barthelemy2011`,</span>
<span class="sd">    :cite:`daskin2013`, :cite:`Okabe2012`,</span>
<span class="sd">    :cite:`Ducruet2014`, :cite:`Weber2016`, for more in-depth discussion on</span>
<span class="sd">    spatial networks, graph theory, and location along networks.</span>
<span class="sd">    For related network-centric software see</span>
<span class="sd">    `Snkit &lt;https://github.com/tomalrussell/snkit&gt;`_ :cite:`tom_russell_2019_3379659`,</span>
<span class="sd">    `SANET &lt;http://sanet.csis.u-tokyo.ac.jp&gt;`_ :cite:`Okabe2006a`,</span>
<span class="sd">    `NetworkX &lt;https://networkx.github.io&gt;`_ :cite:`Hagberg2008`,</span>
<span class="sd">    `Pandana &lt;http://udst.github.io/pandana/&gt;`_ :cite:`Foti2012`,</span>
<span class="sd">    and `OSMnx &lt;https://osmnx.readthedocs.io/en/stable/&gt;`_ :cite:`Boeing2017`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create an instance of a network.</span>

<span class="sd">    &gt;&gt;&gt; import spaghetti</span>
<span class="sd">    &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">    &gt;&gt;&gt; streets_file = examples.get_path(&quot;streets.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ntw = spaghetti.Network(in_data=streets_file)</span>

<span class="sd">    Fetch the number connected components in the network.</span>

<span class="sd">    &gt;&gt;&gt; ntw.network_n_components</span>
<span class="sd">    1</span>

<span class="sd">    Unique component labels in the network.</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; list(numpy.unique(ntw.network_component_labels))</span>
<span class="sd">    [np.int32(0)]</span>

<span class="sd">    Show whether each component of the network is an isolated ring (or not).</span>

<span class="sd">    &gt;&gt;&gt; ntw.network_component_is_ring</span>
<span class="sd">    {np.int32(0): False}</span>

<span class="sd">    Show how many network arcs are associated with the component.</span>

<span class="sd">    &gt;&gt;&gt; arcs = len(ntw.network_component2arc[ntw.network_component_labels[0]])</span>
<span class="sd">    &gt;&gt;&gt; arcs</span>
<span class="sd">    303</span>

<span class="sd">    Do the same as above, but for the graph-theoretic representation</span>
<span class="sd">    of the network object.</span>

<span class="sd">    &gt;&gt;&gt; ntw.graph_n_components</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; list(numpy.unique(ntw.graph_component_labels))</span>
<span class="sd">    [np.int32(0)]</span>
<span class="sd">    &gt;&gt;&gt; ntw.graph_component_is_ring</span>
<span class="sd">    {np.int32(0): False}</span>
<span class="sd">    &gt;&gt;&gt; edges = len(ntw.graph_component2edge[ntw.graph_component_labels[0]])</span>
<span class="sd">    &gt;&gt;&gt; edges</span>
<span class="sd">    179</span>

<span class="sd">    The number of arcs in the network is always greater than or equal</span>
<span class="sd">    to the number of edges in the graph-theoretic representation.</span>

<span class="sd">    &gt;&gt;&gt; arcs &gt;= edges</span>
<span class="sd">    True</span>

<span class="sd">    Snap point observations to the network with attribute information.</span>

<span class="sd">    &gt;&gt;&gt; crimes_file = examples.get_path(&quot;crimes.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ntw.snapobservations(crimes_file, &quot;crimes&quot;, attribute=True)</span>

<span class="sd">    And without attribute information.</span>

<span class="sd">    &gt;&gt;&gt; schools_file = examples.get_path(&quot;schools.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ntw.snapobservations(schools_file, &quot;schools&quot;, attribute=False)</span>

<span class="sd">    Show the point patterns associated with the network.</span>

<span class="sd">    &gt;&gt;&gt; ntw.pointpatterns.keys()</span>
<span class="sd">    dict_keys([&#39;crimes&#39;, &#39;schools&#39;])</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Network.__init__">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">in_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vertex_sig</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
        <span class="n">unique_arcs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">extractgraph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">w_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">weightings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">weights_kws</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>  <span class="c1"># noqa: B006, C408</span>
        <span class="n">vertex_atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># do this when creating a clean network instance from a</span>
        <span class="c1"># shapefile or a geopandas.GeoDataFrame, otherwise a shell</span>
        <span class="c1"># network instance is created (see `split_arcs()` method)</span>
        <span class="k">if</span> <span class="n">in_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set parameters as attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_data</span> <span class="o">=</span> <span class="n">in_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_sig</span> <span class="o">=</span> <span class="n">vertex_sig</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_atol</span> <span class="o">=</span> <span class="n">vertex_atol</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique_arcs</span> <span class="o">=</span> <span class="n">unique_arcs</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># initialize network arcs and arc_lengths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># initialize pointpatterns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># spatial representation of the network</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extractnetwork</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="c1"># extract connected components</span>
            <span class="k">if</span> <span class="n">w_components</span><span class="p">:</span>
                <span class="n">as_graph</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">network_weightings</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">weightings</span><span class="p">:</span>
                    <span class="c1"># set network arc weights to length if weights are</span>
                    <span class="c1"># desired, but no other input in given</span>
                    <span class="n">weightings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span>
                    <span class="n">network_weightings</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># extract contiguity weights from libpysal</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w_network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contiguityweights</span><span class="p">(</span>
                    <span class="n">graph</span><span class="o">=</span><span class="n">as_graph</span><span class="p">,</span>
                    <span class="n">weightings</span><span class="o">=</span><span class="n">weightings</span><span class="p">,</span>
                    <span class="n">weights_kws</span><span class="o">=</span><span class="n">weights_kws</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># identify connected components from the `w_network`</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identify_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_network</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">as_graph</span><span class="p">)</span>

            <span class="c1"># extract the graph -- repeat similar as above</span>
            <span class="c1"># for extracting the network</span>
            <span class="k">if</span> <span class="n">extractgraph</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extractgraph</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">w_components</span><span class="p">:</span>
                    <span class="n">as_graph</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">if</span> <span class="n">network_weightings</span><span class="p">:</span>
                        <span class="n">weightings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">w_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contiguityweights</span><span class="p">(</span>
                        <span class="n">graph</span><span class="o">=</span><span class="n">as_graph</span><span class="p">,</span>
                        <span class="n">weightings</span><span class="o">=</span><span class="n">weightings</span><span class="p">,</span>
                        <span class="n">weights_kws</span><span class="o">=</span><span class="n">weights_kws</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">identify_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_graph</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">as_graph</span><span class="p">)</span>

            <span class="c1"># sorted list of vertex IDs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>


    <span class="k">def</span> <span class="nf">_round_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used internally to round the vertex to a set number of</span>
<span class="sd">        significant digits. If ``sig`` is set to 4, then the following</span>
<span class="sd">        are some possible results for a coordinate are as follows.</span>
<span class="sd">        (1) 0.0xxxx, (2) 0.xxxx, (3) x.xxx, (4) xx.xx,</span>
<span class="sd">        (5) xxx.x, (6) xxxx.0, (7) xxxx0.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : tuple</span>
<span class="sd">            Coordinate (x,y) of the vertex.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set the number of significant digits</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_sig</span>

        <span class="c1"># simply return vertex (x,y) coordinates</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="c1"># for each coordinate in a coordinate pair</span>
        <span class="c1"># if the coordinate location is (0.0) simply return zero</span>
        <span class="c1"># else -- (1) take the absolute value of `val`; (2) take the</span>
        <span class="c1"># base 10 log for [1]; (3) take the floor of [2]; (4) convert</span>
        <span class="c1"># [3] into a negative integer; (5) add `sig - 1` to [4];</span>
        <span class="c1"># (6) round `val` by [5]</span>
        <span class="n">out_v</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">val</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">val</span><span class="p">))))</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">v</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_atol</span><span class="p">:</span>
            <span class="n">out_v</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_atol</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_v</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_v</span><span class="p">)</span>

<div class="viewcode-block" id="Network.identify_components">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.identify_components">[docs]</a>
    <span class="k">def</span> <span class="nf">identify_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify connected component information from a</span>
<span class="sd">        ``libpysal.weights.W`` object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        w : libpysal.weights.W</span>
<span class="sd">            Weights object created from the network segments (either</span>
<span class="sd">            raw or graph-theoretic).</span>
<span class="sd">        graph : bool</span>
<span class="sd">            Flag for a raw network (``False``) or graph-theoretic network</span>
<span class="sd">            (``True``). Default is ``False``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># flag network (arcs) or graph (edges)</span>
        <span class="k">if</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
            <span class="n">obj_type</span> <span class="o">=</span> <span class="s2">&quot;graph_&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span>
            <span class="n">obj_type</span> <span class="o">=</span> <span class="s2">&quot;network_&quot;</span>

        <span class="c1"># connected component count and labels</span>
        <span class="n">n_components</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">n_components</span>
        <span class="n">component_labels</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">component_labels</span>

        <span class="c1"># is the network a single, fully-connected component?</span>
        <span class="n">fully_connected</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n_components</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># link to component lookup</span>
        <span class="n">link2component</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">component_labels</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># component ID lookups: links, lengths, vertices, vertex counts</span>
        <span class="n">component2link</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">component_lengths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">component_vertices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">component_vertex_count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cp_labs_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">component_labels</span><span class="p">)</span>
        <span class="n">l2c_</span> <span class="o">=</span> <span class="n">link2component</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cpl</span> <span class="ow">in</span> <span class="n">cp_labs_</span><span class="p">:</span>
            <span class="n">component2link</span><span class="p">[</span><span class="n">cpl</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l2c_</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">cpl</span><span class="p">])</span>
            <span class="n">c2l_</span> <span class="o">=</span> <span class="n">component2link</span><span class="p">[</span><span class="n">cpl</span><span class="p">]</span>
            <span class="n">arclens_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">component_lengths</span><span class="p">[</span><span class="n">cpl</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arclens_</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">c2l_</span><span class="p">])</span>
            <span class="n">component_vertices</span><span class="p">[</span><span class="n">cpl</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">c2l_</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">link</span><span class="p">}</span>
            <span class="n">component_vertex_count</span><span class="p">[</span><span class="n">cpl</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_vertices</span><span class="p">[</span><span class="n">cpl</span><span class="p">])</span>

        <span class="c1"># longest and largest components</span>
        <span class="n">longest_component</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">component_lengths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">component_lengths</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
        <span class="n">largest_component</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">component_vertex_count</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">component_vertex_count</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>

        <span class="c1"># component to ring lookup</span>
        <span class="n">component_is_ring</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">adj_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">verts</span> <span class="ow">in</span> <span class="n">component_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">component_is_ring</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">_2neighs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">neighs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">neighs</span> <span class="ow">in</span> <span class="n">adj_</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">_2neighs</span><span class="p">):</span>
                <span class="n">component_is_ring</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># attribute label name depends on object type</span>
        <span class="n">c2l_attr_name</span> <span class="o">=</span> <span class="s2">&quot;component2edge&quot;</span> <span class="k">if</span> <span class="n">graph</span> <span class="k">else</span> <span class="s2">&quot;component2arc&quot;</span>

        <span class="c1"># set all new variables into list</span>
        <span class="n">extracted_attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;fully_connected&quot;</span><span class="p">,</span> <span class="n">fully_connected</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;n_components&quot;</span><span class="p">,</span> <span class="n">n_components</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;component_labels&quot;</span><span class="p">,</span> <span class="n">component_labels</span><span class="p">],</span>
            <span class="p">[</span><span class="n">c2l_attr_name</span><span class="p">,</span> <span class="n">component2link</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;component_lengths&quot;</span><span class="p">,</span> <span class="n">component_lengths</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;component_vertices&quot;</span><span class="p">,</span> <span class="n">component_vertices</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;component_vertex_count&quot;</span><span class="p">,</span> <span class="n">component_vertex_count</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;longest_component&quot;</span><span class="p">,</span> <span class="n">longest_component</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;largest_component&quot;</span><span class="p">,</span> <span class="n">largest_component</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;component_is_ring&quot;</span><span class="p">,</span> <span class="n">component_is_ring</span><span class="p">],</span>
        <span class="p">]</span>

        <span class="c1"># iterate over list and set attribute with</span>
        <span class="c1"># either &quot;network&quot; or &quot;graph&quot; extension</span>
        <span class="k">for</span> <span class="n">attr_str</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">extracted_attrs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">+</span> <span class="n">attr_str</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_extractnetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used internally to extract a network.&quot;&quot;&quot;</span>

        <span class="c1"># initialize vertex count</span>
        <span class="n">vertex_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># determine input network data type</span>
        <span class="n">in_dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_data</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">is_libpysal_chains</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">supported_iterables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;list&quot;</span><span class="p">,</span> <span class="s2">&quot;tuple&quot;</span><span class="p">,</span> <span class="s2">&quot;numpy.ndarray&quot;</span><span class="p">]</span>
        <span class="c1"># type error message</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; not supported for network instantiation.&quot;</span>

        <span class="c1"># set appropriate geometries</span>
        <span class="k">if</span> <span class="n">in_dtype</span> <span class="o">==</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span>
            <span class="n">shps</span> <span class="o">=</span> <span class="n">_open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">in_dtype</span> <span class="ow">in</span> <span class="n">supported_iterables</span><span class="p">:</span>
            <span class="n">shps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_data</span>
            <span class="n">shp_type</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">shps</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">shp_type</span> <span class="o">==</span> <span class="s2">&quot;libpysal.cg.shapes.Chain&quot;</span><span class="p">:</span>
                <span class="n">is_libpysal_chains</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shp_type</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">in_dtype</span> <span class="o">==</span> <span class="s2">&quot;libpysal.cg.shapes.Chain&quot;</span><span class="p">:</span>
            <span class="n">shps</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">in_data</span><span class="p">]</span>
            <span class="n">is_libpysal_chains</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">in_dtype</span> <span class="o">==</span> <span class="s2">&quot;geopandas.geodataframe.GeoDataFrame&quot;</span><span class="p">:</span>
            <span class="n">shps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_data</span><span class="o">.</span><span class="n">geometry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">in_dtype</span><span class="p">))</span>

        <span class="c1"># iterate over each record of the network lines</span>
        <span class="k">for</span> <span class="n">shp</span> <span class="ow">in</span> <span class="n">shps</span><span class="p">:</span>
            <span class="c1"># if the segments are native pysal geometries</span>
            <span class="k">if</span> <span class="n">is_libpysal_chains</span><span class="p">:</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="n">shp</span><span class="o">.</span><span class="n">vertices</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># fetch all vertices between euclidean segments</span>
                <span class="c1"># in the line record -- these vertices are</span>
                <span class="c1"># coordinates in an (x, y) tuple.</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">_contW_lists</span><span class="o">.</span><span class="n">_get_verts</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span>

            <span class="c1"># iterate over each vertex (v)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># -- For vertex 1</span>
                <span class="c1"># adjust precision -- this was originally</span>
                <span class="c1"># implemented to handle high-precision</span>
                <span class="c1"># network network vertices</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round_sig</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                <span class="c1"># when the vertex already exists in lookup</span>
                <span class="c1"># set it as the current `vid`</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">vid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="c1"># when the vertex is not present in the lookup</span>
                <span class="c1"># add it and adjust vertex count</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">vid</span> <span class="o">=</span> <span class="n">vertex_count</span>
                    <span class="n">vertex_count</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># -- For vertex 2</span>
                <span class="c1"># repeat the steps above for vertex 1</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round_sig</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nvid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nvid</span> <span class="o">=</span> <span class="n">vertex_count</span>
                    <span class="n">vertex_count</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># records vertex 1 and vertex 2 adjacency</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">vid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nvid</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">nvid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>

                <span class="c1"># Sort the edges so that mono-directional</span>
                <span class="c1"># keys can be stored.</span>
                <span class="n">arc_vertices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">vid</span><span class="p">,</span> <span class="n">nvid</span><span class="p">])</span>
                <span class="n">arc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arc_vertices</span><span class="p">)</span>

                <span class="c1"># record the euclidean arc within the network</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span>

                <span class="c1"># record length</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">arc</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_arcs</span><span class="p">:</span>
            <span class="c1"># Remove duplicate edges and duplicate adjacent nodes.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

<div class="viewcode-block" id="Network.extractgraph">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.extractgraph">[docs]</a>
    <span class="k">def</span> <span class="nf">extractgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Using the existing network representation, create a</span>
<span class="sd">        graph-theoretic representation by removing all vertices with a</span>
<span class="sd">        neighbor incidence of two (non-articulation points). That is, we</span>
<span class="sd">        assume these vertices are bridges between vertices with higher</span>
<span class="sd">        or lower incidence.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize edges and edge_lengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># find all vertices with degree 2 that are not in an isolated</span>
        <span class="c1"># island ring (loop) component. These are non-articulation</span>
        <span class="c1"># points on the graph representation</span>
        <span class="n">non_articulation_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yield_napts</span><span class="p">()</span>
        <span class="c1"># retain non_articulation_points as an attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_articulation_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">non_articulation_points</span><span class="p">)</span>

        <span class="c1"># start with a copy of the spatial representation and</span>
        <span class="c1"># iteratively remove edges deemed to be segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">)</span>

        <span class="c1"># mapping all the &#39;network arcs&#39; contained within a single</span>
        <span class="c1"># &#39;graph represented&#39; edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># build up bridges &quot;rooted&quot; on the initial</span>
        <span class="c1"># non-articulation points</span>
        <span class="n">bridge_roots</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># iterate over all vertices that are not contained within</span>
        <span class="c1"># isolated loops that have a degree of 2</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">non_articulation_points</span><span class="p">:</span>
            <span class="c1"># initialize bridge with an articulation point</span>
            <span class="n">bridge</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="c1"># fetch all vertices adjacent to point `s`</span>
            <span class="c1"># that are also degree 2</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yieldneighbor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">non_articulation_points</span><span class="p">,</span> <span class="n">bridge</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="c1"># extract the current node in `neighbors`</span>
                <span class="n">cnode</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="c1"># remove it from `non_articulation_points`</span>
                <span class="n">non_articulation_points</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span>
                <span class="c1"># add it to bridge</span>
                <span class="n">bridge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span>
                <span class="c1"># fetch neighbors for the current node</span>
                <span class="n">newneighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yieldneighbor</span><span class="p">(</span>
                    <span class="n">cnode</span><span class="p">,</span> <span class="n">non_articulation_points</span><span class="p">,</span> <span class="n">bridge</span>
                <span class="p">)</span>
                <span class="c1"># add the new neighbors back into `neighbors`</span>
                <span class="n">neighbors</span> <span class="o">+=</span> <span class="n">newneighbors</span>

            <span class="c1"># once all potential neighbors are exhausted add the</span>
            <span class="c1"># current bridge of non-articulation points to the</span>
            <span class="c1"># list of rooted bridges</span>
            <span class="n">bridge_roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bridge</span><span class="p">)</span>

        <span class="c1"># iterate over the list of newly created rooted bridges</span>
        <span class="k">for</span> <span class="n">bridge</span> <span class="ow">in</span> <span class="n">bridge_roots</span><span class="p">:</span>
            <span class="c1"># if the vertex is only one non-articulation</span>
            <span class="c1"># point in the bridge</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bridge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># that the singular element of the bridge</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">bridge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># and create a new graph edge from it</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>

                <span class="c1"># identify the arcs to be removed</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">bridge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">bridge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>

                <span class="c1"># remove the network arcs (spatial) from the</span>
                <span class="c1"># graph-theoretic representation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>

                <span class="c1"># remove the former network arc lengths from the</span>
                <span class="c1"># graph edge lengths lookup</span>
                <span class="n">length_e1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span>
                <span class="n">length_e2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">e2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># and add the new edge length in their place</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">new_edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">length_e1</span> <span class="o">+</span> <span class="n">length_e2</span>

                <span class="c1"># update the pointers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edge</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">[</span><span class="n">e2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edge</span>

            <span class="c1"># if there are more than one vertices in the bridge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cumulative_length</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">start_end</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># initialize a redundant set of bridge edges</span>
                <span class="n">redundant</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

                <span class="c1"># iterate over the current bridge</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bridge</span><span class="p">:</span>
                    <span class="c1"># iterate over each node in the bridge</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
                        <span class="c1"># start the bridge with this node</span>
                        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bridge</span><span class="p">:</span>
                            <span class="n">start_end</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                        <span class="c1"># or create a redundant edge with the current</span>
                        <span class="c1"># node and `b`</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">redundant</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">])))</span>

                <span class="c1"># initialize a new graph edge</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">start_end</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

                <span class="c1"># add start_end redundant edge</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">start_end</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">redundant</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">])))</span>

                <span class="c1"># remove all redundant network arcs while</span>
                <span class="c1"># adjusting the graph edge lengths lookup</span>
                <span class="c1"># and the edges_to_arcs lookup</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">redundant</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">cumulative_length</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edge</span>

                <span class="c1"># finally, add the new cumulative edge length</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">[</span><span class="n">new_edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">cumulative_length</span>

            <span class="c1"># add the updated graph edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>

        <span class="c1"># converted the graph edges into a sorted set to prune out</span>
        <span class="c1"># duplicate graph edges created during simplification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">_yield_napts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find all nodes with degree 2 that are not in an isolated</span>
<span class="sd">        island ring (loop) component. These are non-articulation</span>
<span class="sd">        points on the graph representation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        napts : list</span>
<span class="sd">            Non-articulation points on a graph representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># non-articulation points</span>
        <span class="n">napts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># network vertices remaining to evaluate</span>
        <span class="n">unvisted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">while</span> <span class="n">unvisted</span><span class="p">:</span>
            <span class="c1"># iterate over each component</span>
            <span class="k">for</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">ring</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_component_is_ring</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># evaluate for non-articulation points</span>
                <span class="n">napts</span><span class="p">,</span> <span class="n">unvisted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_napts</span><span class="p">(</span>
                    <span class="n">napts</span><span class="p">,</span> <span class="n">unvisted</span><span class="p">,</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">ring</span>
                <span class="p">)</span>

        <span class="c1"># convert set of non-articulation points into list</span>
        <span class="n">napts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">napts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">napts</span>

    <span class="k">def</span> <span class="nf">_evaluate_napts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">napts</span><span class="p">,</span> <span class="n">unvisited</span><span class="p">,</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate one connected component in a network for</span>
<span class="sd">        non-articulation points (``napts``) and return an updated set of</span>
<span class="sd">        ``napts`` and unvisted vertices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        napts : set</span>
<span class="sd">            Non-articulation points (``napts``) in the network. The</span>
<span class="sd">            ``napts`` here do not include those within an isolated</span>
<span class="sd">            loop island.</span>
<span class="sd">        unvisited : set</span>
<span class="sd">            Vertices left to evaluate in the network.</span>
<span class="sd">        component_id : int</span>
<span class="sd">            ID for the network connected component for the</span>
<span class="sd">            current iteration of the algorithm.</span>
<span class="sd">        ring : bool</span>
<span class="sd">            Network component is isolated island loop ``True`` or</span>
<span class="sd">            not ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        napts : set</span>
<span class="sd">            Updated ``napts`` object.</span>
<span class="sd">        unvisited : set</span>
<span class="sd">            Updated ``napts`` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># iterate over each `edge` of the `component`</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_component2arc</span><span class="p">[</span><span class="n">component_id</span><span class="p">]:</span>
            <span class="c1"># each `component` has two vertices</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
                <span class="c1"># if `component` is not an isolated island</span>
                <span class="c1"># and `vertex` has exactly 2 neighbors,</span>
                <span class="c1"># add `vertex` to `napts`</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ring</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">vertex</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">napts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

                <span class="c1"># remove `vertex` from `unvisited` if</span>
                <span class="c1"># it is still in the set else move along to</span>
                <span class="c1"># the next iteration</span>
                <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">suppress</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
                    <span class="n">unvisited</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">napts</span><span class="p">,</span> <span class="n">unvisited</span>

    <span class="k">def</span> <span class="nf">_yieldneighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vtx</span><span class="p">,</span> <span class="n">arc_vertices</span><span class="p">,</span> <span class="n">bridge</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used internally, this method traverses a bridge arc</span>
<span class="sd">        to find the source and destination nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vtx : int</span>
<span class="sd">            The vertex ID.</span>
<span class="sd">        arc_vertices : list</span>
<span class="sd">            All non-articulation points (``napts``) in the network.</span>
<span class="sd">            These are referred to as degree-2 vertices.</span>
<span class="sd">        bridge : list</span>
<span class="sd">            Inital bridge list containing only ``vtx``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes : list</span>
<span class="sd">            Vertices to keep (articulation points). These elements are</span>
<span class="sd">            referred to as nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate empty lis to fill with network articulation</span>
        <span class="c1"># points (nodes with a degree of 1 [endpoints] or greater</span>
        <span class="c1"># than 2 [intersections])</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get all nodes adjacent to `vtx` that are not in the</span>
        <span class="c1"># set of &#39;bridge&#39; vertices</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">vtx</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arc_vertices</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bridge</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nodes</span>

<div class="viewcode-block" id="Network.contiguityweights">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.contiguityweights">[docs]</a>
    <span class="k">def</span> <span class="nf">contiguityweights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">weightings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">from_split</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">weights_kws</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>  <span class="c1"># noqa: B006, C408</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a contiguity-based ``libpysal.weights.W`` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        graph : bool</span>
<span class="sd">            Controls whether the ``libpysal.weights.W`` is generated</span>
<span class="sd">            using the spatial representation (``False``) or the graph</span>
<span class="sd">            representation (``True``). Default is ``True``.</span>
<span class="sd">        weightings : {dict, None}</span>
<span class="sd">            Dictionary of lists of weightings for each arc/edge. Default is ``None``.</span>
<span class="sd">        from_split : bool</span>
<span class="sd">            Flag for whether the method is being called from within</span>
<span class="sd">            ``split_arcs()`` (``True``) or not (``False``). Default is ``False``.</span>
<span class="sd">        weights_kws : dict</span>
<span class="sd">            Keyword arguments for ``libpysal.weights.W``. Default is ``dict()``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         W : libpysal.weights.W</span>
<span class="sd">            A ``W`` representing the binary adjacency of the network.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        libpysal.weights.W</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Instantiate a network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Snap point observations to the network with attribute information.</span>

<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(</span>
<span class="sd">        ...     examples.get_path(&quot;crimes.shp&quot;), &quot;crimes&quot;, attribute=True</span>
<span class="sd">        ... )</span>

<span class="sd">        Find counts per network arc.</span>

<span class="sd">        &gt;&gt;&gt; counts = ntw.count_per_link(</span>
<span class="sd">        ...     ntw.pointpatterns[&quot;crimes&quot;].obs_to_arc, graph=False</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; counts[(50, 165)]</span>
<span class="sd">        4</span>

<span class="sd">        Create a contiguity-based ``W`` object.</span>

<span class="sd">        &gt;&gt;&gt; w = ntw.contiguityweights(graph=False)</span>
<span class="sd">        &gt;&gt;&gt; w.n, w.n_components</span>
<span class="sd">        (303, 1)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        See :cite:`pysal2007` for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate OrderedDict to record network link</span>
        <span class="c1"># adjacency which will be keyed by the link ID (a tuple)</span>
        <span class="c1"># with values being lists of tuples (contiguous links)</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># flag network (arcs) or graph (edges)</span>
        <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="k">if</span> <span class="n">graph</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span>

        <span class="c1"># if weightings are desired instantiate a dictionary</span>
        <span class="c1"># other ignore weightings</span>
        <span class="n">_weights</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">weightings</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># iterate over all links until all possibilities</span>
        <span class="c1"># for network link adjacency are exhausted</span>
        <span class="n">working</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">working</span><span class="p">:</span>
            <span class="c1"># for each network link (1)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="c1"># instantiate a slot in the OrderedDict</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="n">weightings</span><span class="p">:</span>
                    <span class="n">_weights</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># for each network link (2)</span>
                <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                    <span class="c1"># skip if comparing link to itself</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># if link(1) and link(2) share any vertex</span>
                    <span class="c1"># update neighbors adjacency</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="n">neighbors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>

                        <span class="c1"># and add weights if desired</span>
                        <span class="k">if</span> <span class="n">weightings</span><span class="p">:</span>
                            <span class="n">_weights</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weightings</span><span class="p">[</span><span class="n">neigh</span><span class="p">])</span>

                    <span class="c1"># break condition</span>
                    <span class="c1"># -- everything is sorted, so we know when we have</span>
                    <span class="c1"># stepped beyond a possible neighbor</span>
                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">neigh</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">working</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">from_split</span><span class="p">:</span>
                <span class="n">working</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># call libpysal for `W` instance</span>
        <span class="n">weights_kws</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_weights</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">W</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="o">**</span><span class="n">weights_kws</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">w</span></div>


<div class="viewcode-block" id="Network.distancebandweights">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.distancebandweights">[docs]</a>
    <span class="k">def</span> <span class="nf">distancebandweights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">,</span>
        <span class="n">n_processes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">gen_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">weights_kws</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>  <span class="c1"># noqa: B006, C408</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create distance-based weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : float</span>
<span class="sd">            Distance threshold value.</span>
<span class="sd">        n_processes : {int, str}</span>
<span class="sd">            Specify the number of cores to utilize. Default is 1 core.</span>
<span class="sd">            Use ``&quot;all&quot;`` to request all available cores.</span>
<span class="sd">            Specify the exact number of cores with an integer.</span>
<span class="sd">        gen_tree : bool</span>
<span class="sd">            Rebuild shortest path with ``True``, or skip with ``False``.</span>
<span class="sd">            Default is ``False``.</span>
<span class="sd">        weights_kws : dict</span>
<span class="sd">            Keyword arguments for ``libpysal.weights.W``. Default is ``dict()``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        w : libpysal.weights.W</span>
<span class="sd">            A ``W`` object representing the binary adjacency of</span>
<span class="sd">            the network.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        See :cite:`AnselinRey2014` and :cite:`rey_open_2015` for more details</span>
<span class="sd">        regarding spatial weights.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        libpysal.weights.W</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Instantiate an instance of a network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; import warnings</span>
<span class="sd">        &gt;&gt;&gt; streets_file = examples.get_path(&quot;streets.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(in_data=streets_file)</span>

<span class="sd">        Create a contiguity-based ``W`` object based on network distance, ``500``</span>
<span class="sd">        US feet in this case.</span>

<span class="sd">        &gt;&gt;&gt; w = ntw.distancebandweights(</span>
<span class="sd">        ...     threshold=500, weights_kws=dict(silence_warnings=True)</span>
<span class="sd">        ... )</span>

<span class="sd">        Show the number of units in the ``W`` object.</span>

<span class="sd">        &gt;&gt;&gt; w.n</span>
<span class="sd">        230</span>

<span class="sd">        There are 7 components in the ``W`` object.</span>

<span class="sd">        &gt;&gt;&gt; w.n_components</span>
<span class="sd">        7</span>

<span class="sd">        There are ``8`` units with ``3`` neighbors in the ``W`` object.</span>

<span class="sd">        &gt;&gt;&gt; w.histogram[-1]</span>
<span class="sd">        (np.int64(8), np.int64(3))</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if the a vertex-to-vertex network distance matrix is</span>
        <span class="c1"># not present in the `network.Network` object; calculate</span>
        <span class="c1"># one at this point</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;distance_matrix&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_matrix</span><span class="p">(</span><span class="n">n_processes</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="n">gen_tree</span><span class="p">)</span>

        <span class="c1"># identify all network vertices which are within the</span>
        <span class="c1"># `threshold` parameter</span>
        <span class="n">neighbor_query</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>

        <span class="c1"># create an instance for recording neighbors which</span>
        <span class="c1"># inserts a new key if not present in object</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># iterate over neighbors within the `threshold`</span>
        <span class="c1"># and record all network vertices as neighbors</span>
        <span class="c1"># if the vertex is not being compared to itself</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbor_query</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="n">neighbor_query</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">neigh</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>

        <span class="c1"># call libpysal for `W` instance</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">W</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="o">**</span><span class="n">weights_kws</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">w</span></div>


<div class="viewcode-block" id="Network.snapobservations">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.snapobservations">[docs]</a>
    <span class="k">def</span> <span class="nf">snapobservations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idvariable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Snap a point pattern shapefile to a network object. The</span>
<span class="sd">        point pattern is stored in the ``network.pointpattern``</span>
<span class="sd">        attribute of the network object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_data : {geopandas.GeoDataFrame, str}</span>
<span class="sd">            The input geographic data. Either (1) a path to a</span>
<span class="sd">            shapefile (str); or (2) a ``geopandas.GeoDataFrame``.</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to be assigned to the point dataset.</span>
<span class="sd">        idvariable : str</span>
<span class="sd">            Column name to be used as the ID variable.</span>
<span class="sd">        attribute : bool</span>
<span class="sd">            Defines whether attributes should be extracted. ``True`` for</span>
<span class="sd">            attribute extraction. ``False`` for no attribute extraction.</span>
<span class="sd">            Default is ``False``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        See :cite:`doi:10.1111/gean.12211` for a detailed discussion on</span>
<span class="sd">        the modeling consequences of snapping points to spatial networks.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Instantiate a network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; streets_file = examples.get_path(&quot;streets.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(in_data=streets_file)</span>

<span class="sd">        Snap observations to the network.</span>

<span class="sd">        &gt;&gt;&gt; pt_str = &quot;crimes&quot;</span>
<span class="sd">        &gt;&gt;&gt; in_data = examples.get_path(pt_str+&quot;.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(in_data, pt_str, attribute=True)</span>

<span class="sd">        Isolate the number of points in the dataset.</span>

<span class="sd">        &gt;&gt;&gt; ntw.pointpatterns[pt_str].npoints</span>
<span class="sd">        287</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create attribute of `pointpattern` but instantiating a</span>
        <span class="c1"># `network.PointPattern` class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PointPattern</span><span class="p">(</span>
            <span class="n">in_data</span><span class="o">=</span><span class="n">in_data</span><span class="p">,</span> <span class="n">idvariable</span><span class="o">=</span><span class="n">idvariable</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span>
        <span class="p">)</span>

        <span class="c1"># allocate the point observations to the nework</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snap_to_link</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>


<div class="viewcode-block" id="Network.compute_distance_to_vertices">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.compute_distance_to_vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_distance_to_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">arc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an observation on a network arc, return the distance</span>
<span class="sd">        to the two vertices that bound that end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">            The x-coordinate of the snapped point.</span>
<span class="sd">        y : float</span>
<span class="sd">            The y-coordinate of the snapped point.</span>
<span class="sd">        arc : tuple</span>
<span class="sd">            The (vtx0, vtx1) representation of the network arc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d1 : float</span>
<span class="sd">            The distance to vtx0. Always the vertex with the lesser ID.</span>
<span class="sd">        d2 : float</span>
<span class="sd">            The distance to vtx1. Always the vertex with the greater ID.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># distance to vertex 1</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># distance to vertex 2</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span></div>


<div class="viewcode-block" id="Network.compute_snap_dist">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.compute_snap_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_snap_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an observation snapped to a network arc, calculate the</span>
<span class="sd">        distance from the original location to the snapped location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pattern : spaghetti.PointPattern</span>
<span class="sd">            The point pattern object.</span>
<span class="sd">        idx : int</span>
<span class="sd">            The point ID.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : float</span>
<span class="sd">            The euclidean distance from original location to the snapped</span>
<span class="sd">            location.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set of original (x,y) point coordinates</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span>

        <span class="c1"># set of snapped (x,y) point coordinate</span>
        <span class="n">snp</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># distance from the original location to</span>
        <span class="c1"># the snapped location along the network</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">snp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dist</span></div>


    <span class="k">def</span> <span class="nf">_snap_to_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointpattern</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used internally to snap point observations to network arcs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pointpattern : spaghetti.PointPattern</span>
<span class="sd">            The point pattern object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obs_to_arc : dict</span>
<span class="sd">            Dictionary with arcs as keys and lists of points as values.</span>
<span class="sd">        arc_to_obs : dict</span>
<span class="sd">            Dictionary with point IDs as keys and arc tuples as values.</span>
<span class="sd">        dist_to_vertex : dict</span>
<span class="sd">            Dictionary with point IDs as keys and values as dictionaries</span>
<span class="sd">            with keys for vertex IDs and values as distances from point</span>
<span class="sd">            to vertex.</span>
<span class="sd">        dist_snapped : dict</span>
<span class="sd">            Dictionary with point IDs as keys and distance from point</span>
<span class="sd">            to the network arc that it is snapped.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate observations snapped coordinates lookup</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">snapped_coordinates</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># record throw-away arcs (pysal.cg.Chain) enumerator</span>
        <span class="n">arcs_</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># snapped(point)-to-arc lookup</span>
        <span class="n">s2a</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># iterate over network arc IDs</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">:</span>
            <span class="c1"># record the start and end of the arc</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># create a pysal.cg.Chain object of the arc</span>
            <span class="c1"># and add it to the arcs enumerator</span>
            <span class="n">arcs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">_chain_constr</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">]))</span>

            <span class="c1"># add the arc into the snapped(point)-to-arc lookup</span>
            <span class="n">s2a</span><span class="p">[(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arc</span>

        <span class="c1"># instantiate crosswalks</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># point ID to coordinates lookup</span>
        <span class="n">obs_to_arc</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># observations to arcs lookup</span>
        <span class="n">dist_to_vertex</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># distance to vertices lookup</span>
        <span class="n">dist_snapped</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># snapped distance lookup</span>

        <span class="c1"># fetch and records point coordinates keyed by ID</span>
        <span class="k">for</span> <span class="n">point_idx</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">pointpattern</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">points</span><span class="p">[</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span>

        <span class="c1"># snap point observations to the network</span>
        <span class="n">snapped</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">snap_points_to_links</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">arcs_</span><span class="p">)</span>

        <span class="c1"># record obs_to_arc, dist_to_vertex, and dist_snapped</span>
        <span class="c1"># -- iterate over the snapped observation points</span>
        <span class="k">for</span> <span class="n">point_idx</span><span class="p">,</span> <span class="n">snap_info</span> <span class="ow">in</span> <span class="n">snapped</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># fetch the x and y coordinate</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">snap_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># look up the arc from snapped(point)-to-arc</span>
            <span class="n">arc</span> <span class="o">=</span> <span class="n">s2a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">snap_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

            <span class="c1"># add the arc key to observations to arcs lookup</span>
            <span class="k">if</span> <span class="n">arc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obs_to_arc</span><span class="p">:</span>
                <span class="n">obs_to_arc</span><span class="p">[</span><span class="n">arc</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># add the (x,y) coordinates of the original observation</span>
            <span class="c1"># point location to the observations to arcs lookup</span>
            <span class="n">obs_to_arc</span><span class="p">[</span><span class="n">arc</span><span class="p">][</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="c1"># add the (x,y) coordinates of the snapped observation</span>
            <span class="c1"># point location to the snapped coordinates lookup</span>
            <span class="n">pointpattern</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="c1"># calculate the distance to the left and right vertex</span>
            <span class="c1"># along the network link from the snapped point location</span>
            <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_distance_to_vertices</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">arc</span><span class="p">)</span>

            <span class="c1"># record the distances in the distance to vertices lookup</span>
            <span class="n">dist_to_vertex</span><span class="p">[</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">d1</span><span class="p">,</span> <span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">d2</span><span class="p">}</span>

            <span class="c1"># record the snapped distance</span>
            <span class="n">dist_snapped</span><span class="p">[</span><span class="n">point_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_snap_dist</span><span class="p">(</span><span class="n">pointpattern</span><span class="p">,</span> <span class="n">point_idx</span><span class="p">)</span>

        <span class="c1"># instantiate observations to network vertex lookup</span>
        <span class="n">obs_to_vertex</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># iterate over the observations to arcs lookup</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obs_to_arc</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># record the left and right vertex ids</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">obs_to_vertex</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">keys</span>
            <span class="n">obs_to_vertex</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">keys</span>

        <span class="c1"># iterate over components and assign observations</span>
        <span class="n">component_to_obs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">_arcids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_component2arc</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">component_to_obs</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lk</span><span class="p">,</span> <span class="n">odict</span> <span class="ow">in</span> <span class="n">obs_to_arc</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">lk</span> <span class="ow">in</span> <span class="n">_arcids</span><span class="p">:</span>
                    <span class="n">component_to_obs</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">odict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># set crosswalks as attributes of the `pointpattern` class</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">obs_to_arc</span> <span class="o">=</span> <span class="n">obs_to_arc</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">component_to_obs</span> <span class="o">=</span> <span class="n">component_to_obs</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">dist_to_vertex</span> <span class="o">=</span> <span class="n">dist_to_vertex</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">dist_snapped</span> <span class="o">=</span> <span class="n">dist_snapped</span>
        <span class="n">pointpattern</span><span class="o">.</span><span class="n">obs_to_vertex</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obs_to_vertex</span><span class="p">)</span>

<div class="viewcode-block" id="Network.count_per_link">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.count_per_link">[docs]</a>
    <span class="k">def</span> <span class="nf">count_per_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs_on</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the counts per arc or edge (link).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obs_on : dict</span>
<span class="sd">            Dictionary of observations on the network.</span>
<span class="sd">            Either in the form ``{(&lt;LINK&gt;):{&lt;POINT_ID&gt;:(&lt;COORDS&gt;)}}``</span>
<span class="sd">            or ``{&lt;LINK&gt;:[(&lt;COORD&gt;),(&lt;COORD&gt;)]}``.</span>
<span class="sd">        graph : bool</span>
<span class="sd">            Count observations on graph edges (``True``) or</span>
<span class="sd">            network arcs (``False``). Default is ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : dict</span>
<span class="sd">            Counts per network link in the form ``{(&lt;LINK&gt;):&lt;COUNT&gt;}``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Note that this passes the ``obs_to_arc`` or ``obs_to_edge`` attribute</span>
<span class="sd">        of a point pattern snapped to the network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Snap observations to the network.</span>

<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(</span>
<span class="sd">        ...     examples.get_path(&quot;crimes.shp&quot;), &quot;crimes&quot;, attribute=True</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; counts = ntw.count_per_link(</span>
<span class="sd">        ...     ntw.pointpatterns[&quot;crimes&quot;].obs_to_arc, graph=False</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; counts[(140, 142)]</span>
<span class="sd">        10</span>

<span class="sd">        &gt;&gt;&gt; s = sum([v for v in list(counts.values())])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        287</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate observation counts by link lookup</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># graph-theoretic object of nodes and edges</span>
        <span class="k">if</span> <span class="n">graph</span><span class="p">:</span>
            <span class="c1"># iterate the links-to-observations lookup</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">observations</span> <span class="ow">in</span> <span class="n">obs_on</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># isolate observation count for the link</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>

                <span class="c1"># extract link (edges) key</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs_to_edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                <span class="c1"># either add to current count or a dictionary</span>
                <span class="c1"># entry or create new dictionary entry</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cnt</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span>

        <span class="c1"># network object of arcs and vertices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># simplified version of the above process</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obs_on</span><span class="p">:</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_on</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">counts</span></div>


    <span class="k">def</span> <span class="nf">_newpoint_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arc</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used internally to compute new point coordinates during snapping.&quot;&quot;&quot;</span>

        <span class="c1"># extract coordinates for vertex 1 of arc</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># extract coordinates for vertex 2 of arc</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if the network arc is vertical set the (x) coordinate</span>
        <span class="c1"># and proceed to calculating the (y) coordinate</span>
        <span class="k">if</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span>

            <span class="c1"># if the vertical direction is positive from</span>
            <span class="c1"># vertex 1 to vertex 2 on the euclidean plane</span>
            <span class="k">if</span> <span class="n">y1</span> <span class="o">&lt;</span> <span class="n">y2</span><span class="p">:</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">distance</span>

            <span class="c1"># if the vertical direction is negative from</span>
            <span class="c1"># vertex 1 to vertex 2 on the euclidean plane</span>
            <span class="c1"># -- this shouldn&#39;t happen due to vertex sorting in</span>
            <span class="c1"># -- self._extractnetwork() and self.extractgraph()</span>
            <span class="k">elif</span> <span class="n">y1</span> <span class="o">&gt;</span> <span class="n">y2</span><span class="p">:</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">distance</span>

            <span class="c1"># otherwise the link is zero-length</span>
            <span class="c1"># -- this should never happen</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="n">y1</span>

            <span class="k">return</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span>

        <span class="c1"># calculate the slope of the arc, `m`</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>

        <span class="c1"># if the horizontal direction is negative from</span>
        <span class="c1"># vertex 1 to vertex 2 on the euclidean plane</span>
        <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># if the horizontal direction is positive from</span>
        <span class="c1"># vertex 1 to vertex 2 on the euclidean plane</span>
        <span class="k">elif</span> <span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># calculate the (y) coordinate</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y1</span>

        <span class="c1"># the new (x,y) coordinates for the snapped observation</span>
        <span class="k">return</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span>

<div class="viewcode-block" id="Network.simulate_observations">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.simulate_observations">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_observations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a simulated point pattern on the network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        count : int</span>
<span class="sd">            The number of points to create.</span>
<span class="sd">        distribution : str</span>
<span class="sd">            A distribution of random points. Currently, the only</span>
<span class="sd">            supported distribution is uniform.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        random_pts : dict</span>
<span class="sd">            Keys are the edge tuple. Values are lists of new point coordinates.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        numpy.random.Generator.uniform</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Instantiate a network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Snap observations to the network.</span>

<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(</span>
<span class="sd">        ...     examples.get_path(&quot;crimes.shp&quot;), &quot;crimes&quot;, attribute=True</span>
<span class="sd">        ... )</span>

<span class="sd">        Isolate the number of points in the dataset.</span>

<span class="sd">        &gt;&gt;&gt; npts = ntw.pointpatterns[&quot;crimes&quot;].npoints</span>
<span class="sd">        &gt;&gt;&gt; npts</span>
<span class="sd">        287</span>

<span class="sd">        Simulate ``npts`` number of points along the network</span>
<span class="sd">        in a `uniform` distribution.</span>

<span class="sd">        &gt;&gt;&gt; sim = ntw.simulate_observations(npts)</span>
<span class="sd">        &gt;&gt;&gt; isinstance(sim, spaghetti.network.SimulatedPointPattern)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; sim.npoints</span>
<span class="sd">        287</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate an empty `SimulatedPointPattern()`</span>
        <span class="n">simpts</span> <span class="o">=</span> <span class="n">SimulatedPointPattern</span><span class="p">()</span>

        <span class="c1"># record throw-away arcs enumerator</span>
        <span class="n">arcs_</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># create array and fill each entry as length of network arc</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">arcs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># cumulative network length</span>
        <span class="n">stops</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
        <span class="n">cumlen</span> <span class="o">=</span> <span class="n">stops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># create lengths with a uniform distribution</span>
        <span class="k">if</span> <span class="n">distribution</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">nrandompts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cumlen</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">count</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">distribution</span><span class="si">}</span><span class="s2"> distribution not currently supported.&quot;</span><span class="p">)</span>

        <span class="c1"># iterate over random distances created above</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nrandompts</span><span class="p">):</span>
            <span class="c1"># take the first element of the index array (arc ID) where the</span>
            <span class="c1"># random distance is greater than that of its value in `stops`</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">stops</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># assign the simulated point to the arc</span>
            <span class="n">assignment_arc</span> <span class="o">=</span> <span class="n">arcs_</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="c1"># calculate and set the distance from the arc start</span>
            <span class="n">distance_from_start</span> <span class="o">=</span> <span class="n">stops</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span>

            <span class="c1"># populate the coordinates dict</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newpoint_coords</span><span class="p">(</span><span class="n">assignment_arc</span><span class="p">,</span> <span class="n">distance_from_start</span><span class="p">)</span>

            <span class="c1"># record the snapped coordinates and associated vertices</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">obs_to_vertex</span><span class="p">[</span><span class="n">assignment_arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">obs_to_vertex</span><span class="p">[</span><span class="n">assignment_arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># calculate and set the distance from the arc end</span>
            <span class="n">distance_from_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">arcs_</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">-</span> <span class="n">distance_from_start</span>

            <span class="c1"># populate the distances to vertices</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">dist_to_vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">assignment_arc</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">distance_from_start</span><span class="p">,</span>
                <span class="n">assignment_arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">distance_from_end</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="c1"># set snapped coordinates and point count attributes</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">simpts</span><span class="o">.</span><span class="n">snapped_coordinates</span>
            <span class="n">simpts</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">simpts</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">simpts</span></div>


<div class="viewcode-block" id="Network.enum_links_vertex">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.enum_links_vertex">[docs]</a>
    <span class="k">def</span> <span class="nf">enum_links_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the arcs (links) adjacent to vertices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v0 : int</span>
<span class="sd">            The vertex ID.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        links : list</span>
<span class="sd">            List of tuple arcs adjacent to the vertex.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create an instance of a network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Enumerate the links/arcs that are adjacent to vertex ``24``.</span>

<span class="sd">        &gt;&gt;&gt; ntw.enum_links_vertex(24)</span>
<span class="sd">        [(24, 48), (24, 25), (24, 26)]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate links list</span>
        <span class="n">links</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">neighbor_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span>

        <span class="c1"># enumerate links associated with the current vertex</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbor_vertices</span><span class="p">:</span>
            <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">v0</span><span class="p">])))</span>

        <span class="k">return</span> <span class="n">links</span></div>


<div class="viewcode-block" id="Network.full_distance_matrix">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.full_distance_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">full_distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_processes</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;All vertex-to-vertex distances on a network. This method</span>
<span class="sd">        is called from within ``allneighbordistances()``,</span>
<span class="sd">        ``nearestneighbordistances()``, and ``distancebandweights()``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_processes : int</span>
<span class="sd">            Specify the number of cores to utilize. Default is 1 core.</span>
<span class="sd">            Use ``&quot;all&quot;`` to request all available cores.</span>
<span class="sd">            Specify the exact number of cores with an integer.</span>
<span class="sd">        gen_tree : bool</span>
<span class="sd">            Rebuild shortest path ``True``, or skip ``False``.</span>
<span class="sd">            Default is ``False``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Based on :cite:`Dijkstra1959a` and :cite:`doi:10.1002/9781119967101.ch3`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create an empty matrix which will store shortest path distance</span>
        <span class="n">nvtx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nvtx</span><span class="p">,</span> <span class="n">nvtx</span><span class="p">))</span>

        <span class="c1"># create `network_trees` attribute that stores</span>
        <span class="c1"># all network path trees (if desired)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network_trees</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># single-core processing</span>
        <span class="k">if</span> <span class="n">n_processes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># iterate over each network vertex</span>
            <span class="k">for</span> <span class="n">vtx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">:</span>
                <span class="c1"># calculate the shortest path and preceding</span>
                <span class="c1"># vertices for traversal route</span>
                <span class="n">distance</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dijkstra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vtx</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

                <span class="c1"># generate the shortest path tree</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">generatetree</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="k">if</span> <span class="n">gen_tree</span> <span class="k">else</span> <span class="kc">None</span>

                <span class="c1"># populate distances and paths</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network_trees</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span>

        <span class="c1"># multiprocessing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set up multiprocessing schema</span>
            <span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
            <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">repeat</span>

            <span class="n">cores</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="k">if</span> <span class="n">n_processes</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">n_processes</span>

            <span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">cores</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
                <span class="c1"># calculate the shortest path and preceding</span>
                <span class="c1"># vertices for traversal route by mapping each process</span>
                <span class="n">distance_pred</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="n">util</span><span class="o">.</span><span class="n">dijkstra_mp</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># set range of iterations</span>
                <span class="n">iterations</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distance_pred</span><span class="p">))</span>

                <span class="c1"># fill shortest paths</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="p">[</span><span class="n">distance_pred</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">]</span>

                <span class="c1"># fill preceding vertices</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distance_pred</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">])</span>

                <span class="c1"># iterate of network vertices and generate</span>
                <span class="c1"># the shortest path tree for each</span>
                <span class="k">for</span> <span class="n">vtx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">:</span>
                    <span class="n">tree</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">generatetree</span><span class="p">(</span><span class="n">pred</span><span class="p">[</span><span class="n">vtx</span><span class="p">])</span> <span class="k">if</span> <span class="n">gen_tree</span> <span class="k">else</span> <span class="kc">None</span>

                    <span class="c1"># populate distances and paths</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">network_trees</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="Network.allneighbordistances">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.allneighbordistances">[docs]</a>
    <span class="k">def</span> <span class="nf">allneighbordistances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sourcepattern</span><span class="p">,</span>
        <span class="n">destpattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_diagonal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_processes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">gen_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snap_dist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute either all distances between :math:`i` and :math:`j` in a</span>
<span class="sd">        single point pattern or all distances between each :math:`i` from a</span>
<span class="sd">        source pattern and all :math:`j` from a destination pattern.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sourcepattern : {str, spaghetti.PointPattern}</span>
<span class="sd">            The key of a point pattern snapped to the network or</span>
<span class="sd">            the full ``spaghetti.PointPattern`` object.</span>
<span class="sd">        destpattern : str</span>
<span class="sd">            (Optional) The key of a point pattern snapped to the network</span>
<span class="sd">            or the full ``spaghetti.PointPattern`` object.</span>
<span class="sd">        fill_diagonal : {float, int}</span>
<span class="sd">            (Optional) Fill the diagonal of the cost matrix. Default is</span>
<span class="sd">            ``None`` and will populate the diagonal with ``numpy.nan``.</span>
<span class="sd">            Do not declare a ``destpattern`` for a custom</span>
<span class="sd">            ``fill_diagonal``.</span>
<span class="sd">        n_processes : {int, str}</span>
<span class="sd">            Specify the number of cores to utilize. Default is 1 core.</span>
<span class="sd">            Use ``&quot;all&quot;`` to request all available cores.</span>
<span class="sd">            Specify the exact number of cores with an integer.</span>
<span class="sd">        gen_tree : bool</span>
<span class="sd">            Rebuild shortest path ``True``, or skip ``False``.</span>
<span class="sd">            Default is ``False``.</span>
<span class="sd">        snap_dist : bool</span>
<span class="sd">            Flag as ``True`` to include the distance from the original</span>
<span class="sd">            location to the snapped location along the network. Default</span>
<span class="sd">            is ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nearest : numpy.ndarray</span>
<span class="sd">            An array of shape (n,m) storing distances between all</span>
<span class="sd">            source and destination points.</span>
<span class="sd">        tree_nearest : dict</span>
<span class="sd">            Nearest network node to point pattern vertex shortest</span>
<span class="sd">            path lookup. The values of the dictionary are a tuple</span>
<span class="sd">            of the nearest source vertex and the nearest destination</span>
<span class="sd">            vertex to query the lookup tree. If two observations are</span>
<span class="sd">            snapped to the same network arc a flag of -.1 is set for</span>
<span class="sd">            both the source and destination network vertex</span>
<span class="sd">            indicating the same arc is used while also raising an</span>
<span class="sd">            ``IndexError`` when rebuilding the path.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a network instance.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Snap observations to the network.</span>

<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(</span>
<span class="sd">        ...     examples.get_path(&quot;crimes.shp&quot;), &quot;crimes&quot;, attribute=True</span>
<span class="sd">        ... )</span>

<span class="sd">        Calculate all distances between observations in the ``crimes`` dataset.</span>

<span class="sd">        &gt;&gt;&gt; s2s_dist = ntw.allneighbordistances(&quot;crimes&quot;)</span>

<span class="sd">        If calculating a ``type-a`` to ``type-a`` distance matrix</span>
<span class="sd">        the distance between an observation and itself is ``nan`` and</span>
<span class="sd">        the distance between one observation and another will be positive value.</span>

<span class="sd">        &gt;&gt;&gt; s2s_dist[0,0], s2s_dist[1,0]</span>
<span class="sd">        (np.float64(nan), np.float64(3105.189475447081))</span>

<span class="sd">        If calculating a ``type-a`` to ``type-b`` distance matrix</span>
<span class="sd">        the distance between all observations will likely be positive</span>
<span class="sd">        values, may be zero (or approximately zero), but will never be negative.</span>

<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(</span>
<span class="sd">        ...     examples.get_path(&quot;schools.shp&quot;), &quot;schools&quot;, attribute=False</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2d_dist = ntw.allneighbordistances(&quot;crimes&quot;, destpattern=&quot;schools&quot;)</span>
<span class="sd">        &gt;&gt;&gt; numpy.round((s2d_dist[0,0], s2d_dist[1,0]), 5)</span>
<span class="sd">        array([4520.72354, 6340.42297])</span>


<span class="sd">        Shortest paths can also be reconstructed when desired by</span>
<span class="sd">        setting the ``gen_tree`` keyword argument to ``True``. Here</span>
<span class="sd">        it is shown that the shortest path between school ``6`` and</span>
<span class="sd">        school ``7`` flows along network arcs through network</span>
<span class="sd">        vertices ``173`` and ``64``. The ``ntw.network_trees`` attribute</span>
<span class="sd">        may then be queried for the network elements comprising that path.</span>

<span class="sd">        &gt;&gt;&gt; d2d_dist, tree = ntw.allneighbordistances(&quot;schools&quot;, gen_tree=True)</span>
<span class="sd">        &gt;&gt;&gt; tree[(6, 7)]</span>
<span class="sd">        (173, 64)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate the network vertex to vertex distance matrix</span>
        <span class="c1"># if it is not already an attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;distance_matrix&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_matrix</span><span class="p">(</span><span class="n">n_processes</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="n">gen_tree</span><span class="p">)</span>

        <span class="c1"># set the source and destination observation point patterns</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sourcepattern</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">sourcepattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">sourcepattern</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">destpattern</span><span class="p">:</span>
                <span class="n">destpattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">destpattern</span><span class="p">]</span>

        <span class="c1"># source pattern setup</span>
        <span class="c1"># set local copy of source pattern index</span>
        <span class="n">src_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sourcepattern</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># set local copy of source distance to vertex lookup</span>
        <span class="n">src_d2v</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sourcepattern</span><span class="o">.</span><span class="n">dist_to_vertex</span><span class="p">)</span>
        <span class="c1"># source point count</span>
        <span class="n">nsource_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span>
        <span class="c1"># create source point to network vertex lookup</span>
        <span class="n">src_vertices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">src_indices</span><span class="p">:</span>
            <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">src_d2v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">src_vertices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

        <span class="c1"># destination pattern setup</span>
        <span class="c1"># if only a source pattern is specified, also set it as</span>
        <span class="c1"># the destination pattern</span>
        <span class="n">symmetric</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">destpattern</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">symmetric</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">destpattern</span> <span class="o">=</span> <span class="n">sourcepattern</span>
        <span class="c1"># set local copy of destination pattern index</span>
        <span class="n">dest_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">destpattern</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># set local copy of destination distance to vertex lookup</span>
        <span class="n">dst_d2v</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">destpattern</span><span class="o">.</span><span class="n">dist_to_vertex</span><span class="p">)</span>
        <span class="c1"># destination point count</span>
        <span class="n">ndest_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dest_indices</span><span class="p">)</span>
        <span class="c1"># create `deepcopy` of destination points to</span>
        <span class="c1"># consider for searching</span>
        <span class="n">dest_searchpts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dest_indices</span><span class="p">)</span>
        <span class="c1"># create destination point to network vertex lookup</span>
        <span class="n">dest_vertices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dest_indices</span><span class="p">:</span>
            <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">dst_d2v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">dest_vertices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

        <span class="c1"># add snapping distance to each pointpattern</span>
        <span class="k">if</span> <span class="n">snap_dist</span><span class="p">:</span>
            <span class="c1"># declare both point patterns and both</span>
            <span class="c1"># distance to vertex lookup in single lists</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span><span class="n">sourcepattern</span><span class="p">,</span> <span class="n">destpattern</span><span class="p">]</span>
            <span class="n">dist_copies</span> <span class="o">=</span> <span class="p">[</span><span class="n">src_d2v</span><span class="p">,</span> <span class="n">dst_d2v</span><span class="p">]</span>
            <span class="c1"># iterate over each point pattern</span>
            <span class="k">for</span> <span class="n">elm</span><span class="p">,</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">patterns</span><span class="p">):</span>
                <span class="c1"># extract associated vertex distances</span>
                <span class="k">for</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">dists_dict</span> <span class="ow">in</span> <span class="n">dist_copies</span><span class="p">[</span><span class="n">elm</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># add snapped distance to each point</span>
                    <span class="k">for</span> <span class="n">vidx</span><span class="p">,</span> <span class="n">vdist</span> <span class="ow">in</span> <span class="n">dists_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">dists_dict</span><span class="p">[</span><span class="n">vidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vdist</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">dist_snapped</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span>

        <span class="c1"># output setup</span>
        <span class="c1"># create empty source x destination array</span>
        <span class="c1"># and fill with infinity values</span>
        <span class="n">nearest</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nsource_pts</span><span class="p">,</span> <span class="n">ndest_pts</span><span class="p">))</span>
        <span class="n">nearest</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># create empty dictionary to store path trees</span>
        <span class="n">tree_nearest</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># iterate over each point in sources</span>
        <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">src_indices</span><span class="p">:</span>
            <span class="c1"># get the source vertices and dist to source vertices</span>
            <span class="n">source1</span><span class="p">,</span> <span class="n">source2</span> <span class="o">=</span> <span class="n">src_vertices</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">src_vertices</span><span class="p">[</span><span class="n">p1</span><span class="p">])</span>

            <span class="c1"># distance from source vertex1 to point and</span>
            <span class="c1"># distance from source vertex2 to point</span>
            <span class="n">sdist1</span><span class="p">,</span> <span class="n">sdist2</span> <span class="o">=</span> <span class="n">src_d2v</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>
                <span class="c1"># only compute the upper triangle if symmetric</span>
                <span class="n">dest_searchpts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

            <span class="c1"># iterate over each point remaining in destinations</span>
            <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">dest_searchpts</span><span class="p">:</span>
                <span class="c1"># get the destination vertices and</span>
                <span class="c1"># dist to destination vertices</span>
                <span class="n">dest1</span><span class="p">,</span> <span class="n">dest2</span> <span class="o">=</span> <span class="n">dest_vertices</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dest_vertices</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span>

                <span class="c1"># when the observations are snapped to the same arc</span>
                <span class="k">if</span> <span class="n">set1</span> <span class="o">==</span> <span class="n">set2</span><span class="p">:</span>
                    <span class="c1"># calculate only the length between points along</span>
                    <span class="c1"># that arc</span>
                    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">sourcepattern</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
                    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">destpattern</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>

                    <span class="n">computed_length</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">compute_length</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                    <span class="n">nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">computed_length</span>

                    <span class="c1"># set the nearest network vertices to a flag of -.1</span>
                    <span class="c1"># indicating the same arc is used while also raising</span>
                    <span class="c1"># and indexing error when rebuilding the path</span>
                    <span class="n">tree_nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">SAME_SEGMENT</span>

                <span class="c1"># otherwise lookup distance between the source and</span>
                <span class="c1"># destination vertex</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># distance from destination vertex1 to point and</span>
                    <span class="c1"># distance from destination vertex2 to point</span>
                    <span class="n">ddist1</span><span class="p">,</span> <span class="n">ddist2</span> <span class="o">=</span> <span class="n">dst_d2v</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

                    <span class="c1"># set the four possible combinations of</span>
                    <span class="c1"># source to destination shortest path traversal</span>
                    <span class="n">d11</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">[</span><span class="n">source1</span><span class="p">][</span><span class="n">dest1</span><span class="p">]</span>
                    <span class="n">d21</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">[</span><span class="n">source2</span><span class="p">][</span><span class="n">dest1</span><span class="p">]</span>
                    <span class="n">d12</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">[</span><span class="n">source1</span><span class="p">][</span><span class="n">dest2</span><span class="p">]</span>
                    <span class="n">d22</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">[</span><span class="n">source2</span><span class="p">][</span><span class="n">dest2</span><span class="p">]</span>

                    <span class="c1"># find the shortest distance from the path passing</span>
                    <span class="c1"># through each of the two origin vertices to the</span>
                    <span class="c1"># first destination vertex</span>
                    <span class="n">sd_1</span> <span class="o">=</span> <span class="n">d11</span> <span class="o">+</span> <span class="n">sdist1</span>
                    <span class="n">sd_21</span> <span class="o">=</span> <span class="n">d21</span> <span class="o">+</span> <span class="n">sdist2</span>
                    <span class="n">sp_combo1</span> <span class="o">=</span> <span class="n">source1</span><span class="p">,</span> <span class="n">dest1</span>
                    <span class="k">if</span> <span class="n">sd_1</span> <span class="o">&gt;</span> <span class="n">sd_21</span><span class="p">:</span>
                        <span class="n">sd_1</span> <span class="o">=</span> <span class="n">sd_21</span>
                        <span class="n">sp_combo1</span> <span class="o">=</span> <span class="n">source2</span><span class="p">,</span> <span class="n">dest1</span>

                    <span class="c1"># now add the point to vertex1 distance on</span>
                    <span class="c1"># the destination arc</span>
                    <span class="n">len_1</span> <span class="o">=</span> <span class="n">sd_1</span> <span class="o">+</span> <span class="n">ddist1</span>

                    <span class="c1"># repeat the prior but now for the paths entering</span>
                    <span class="c1"># at the second vertex of the second arc</span>
                    <span class="n">sd_2</span> <span class="o">=</span> <span class="n">d12</span> <span class="o">+</span> <span class="n">sdist1</span>
                    <span class="n">sd_22</span> <span class="o">=</span> <span class="n">d22</span> <span class="o">+</span> <span class="n">sdist2</span>
                    <span class="n">sp_combo2</span> <span class="o">=</span> <span class="n">source1</span><span class="p">,</span> <span class="n">dest2</span>
                    <span class="k">if</span> <span class="n">sd_2</span> <span class="o">&gt;</span> <span class="n">sd_22</span><span class="p">:</span>
                        <span class="n">sd_2</span> <span class="o">=</span> <span class="n">sd_22</span>
                        <span class="n">sp_combo2</span> <span class="o">=</span> <span class="n">source2</span><span class="p">,</span> <span class="n">dest2</span>
                    <span class="n">len_2</span> <span class="o">=</span> <span class="n">sd_2</span> <span class="o">+</span> <span class="n">ddist2</span>

                    <span class="c1"># now find the shortest distance path between point</span>
                    <span class="c1"># 1 on arc 1 and point 2 on arc 2, and assign</span>
                    <span class="n">sp_12</span> <span class="o">=</span> <span class="n">len_1</span>
                    <span class="n">s_vertex</span><span class="p">,</span> <span class="n">d_vertex</span> <span class="o">=</span> <span class="n">sp_combo1</span>
                    <span class="k">if</span> <span class="n">len_1</span> <span class="o">&gt;</span> <span class="n">len_2</span><span class="p">:</span>
                        <span class="n">sp_12</span> <span class="o">=</span> <span class="n">len_2</span>
                        <span class="n">s_vertex</span><span class="p">,</span> <span class="n">d_vertex</span> <span class="o">=</span> <span class="n">sp_combo2</span>

                    <span class="c1"># set distance and path tree</span>
                    <span class="n">nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp_12</span>
                    <span class="n">tree_nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s_vertex</span><span class="p">,</span> <span class="n">d_vertex</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>
                    <span class="c1"># mirror the upper and lower triangle</span>
                    <span class="c1"># when symmetric</span>
                    <span class="n">nearest</span><span class="p">[</span><span class="n">p2</span><span class="p">,</span> <span class="n">p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>

        <span class="c1"># populate the main diagonal when symmetric</span>
        <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>
            <span class="c1"># fill the matrix diagonal with NaN values is no fill</span>
            <span class="c1"># value is specified</span>
            <span class="k">if</span> <span class="n">fill_diagonal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">nearest</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># otherwise fill with specified value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">nearest</span><span class="p">,</span> <span class="n">fill_diagonal</span><span class="p">)</span>

        <span class="c1"># if the nearest path tree is desired return it along</span>
        <span class="c1"># with the cost matrix</span>
        <span class="k">if</span> <span class="n">gen_tree</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nearest</span><span class="p">,</span> <span class="n">tree_nearest</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nearest</span></div>


<div class="viewcode-block" id="Network.nearestneighbordistances">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.nearestneighbordistances">[docs]</a>
    <span class="k">def</span> <span class="nf">nearestneighbordistances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sourcepattern</span><span class="p">,</span>
        <span class="n">destpattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_processes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">gen_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">all_dists</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snap_dist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_zero_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the interpattern nearest neighbor distances or the</span>
<span class="sd">        intrapattern nearest neighbor distances between a source</span>
<span class="sd">        pattern and a destination pattern.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sourcepattern : str</span>
<span class="sd">            The key of a point pattern snapped to the network.</span>
<span class="sd">        destpattern : str</span>
<span class="sd">            (Optional) The key of a point pattern snapped to the</span>
<span class="sd">            network.</span>
<span class="sd">        n_processes : {int, str}</span>
<span class="sd">            Specify the number of cores to utilize. Default is 1 core.</span>
<span class="sd">            Use ``&quot;all&quot;`` to request all available cores.</span>
<span class="sd">            Specify the exact number of cores with an integer.</span>
<span class="sd">        gen_tree : bool</span>
<span class="sd">            Rebuild shortest path ``True``, or skip ``False``.</span>
<span class="sd">            Default is ``False``.</span>
<span class="sd">        all_dists : numpy.ndarray</span>
<span class="sd">            An array of shape :math:`(n,n)` storing distances between all</span>
<span class="sd">            points.</span>
<span class="sd">        snap_dist : bool</span>
<span class="sd">            Flag as ``True`` to include the distance from the original</span>
<span class="sd">            location to the snapped location along the network. Default</span>
<span class="sd">            is ``False``.</span>
<span class="sd">        keep_zero_dist : bool</span>
<span class="sd">            Include zero values in minimum distance ``True`` or exclude</span>
<span class="sd">            ``False``. Default is ``True``. If the source pattern is the</span>
<span class="sd">            same as the destination pattern the diagonal is filled with</span>
<span class="sd">            ``numpy.nan``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nearest : dict</span>
<span class="sd">            Nearest neighbor distances keyed by the source point ID with</span>
<span class="sd">            the value as as tuple of lists containing</span>
<span class="sd">            nearest destination point ID(s) and distance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Instantiate a network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Snap observations to the network.</span>

<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(examples.get_path(&quot;crimes.shp&quot;), &quot;crimes&quot;)</span>

<span class="sd">        Fetch nearest neighbor distances while (potentially)</span>
<span class="sd">        keeping neighbors that have been geocoded directly on top of</span>
<span class="sd">        each other. Here it is demonstrated that observation ``11``</span>
<span class="sd">        has two neighbors (``18`` and ``19``) at an exactly equal distance.</span>
<span class="sd">        However, observation ``18`` is shown to have only one neighbor</span>
<span class="sd">        (``18``) with no distance between them.</span>

<span class="sd">        &gt;&gt;&gt; nn = ntw.nearestneighbordistances(&quot;crimes&quot;, keep_zero_dist=True)</span>
<span class="sd">        &gt;&gt;&gt; nn[11], nn[18]</span>
<span class="sd">        (([18, 19], np.float64(165.33982412719126)), ([19], np.float64(0.0)))</span>


<span class="sd">        This may be remedied by setting the ``keep_zero_dist`` keyword</span>
<span class="sd">        argument to ``False``. With this parameter set, observation ``11``</span>
<span class="sd">        still has the same neighbor/distance values, but</span>
<span class="sd">        observation ``18`` now has a single nearest neighbor (``11``)</span>
<span class="sd">        with a non-zero, postive distance.</span>

<span class="sd">        &gt;&gt;&gt; nn = ntw.nearestneighbordistances(&quot;crimes&quot;, keep_zero_dist=False)</span>
<span class="sd">        &gt;&gt;&gt; nn[11], nn[18]</span>
<span class="sd">        (([18, 19], np.float64(165.33982412719126)), ([11], np.float64(165.33982412719126)))</span>

<span class="sd">        There are valid reasons for both retaining or masking zero distance</span>
<span class="sd">        neighbors. When conducting analysis, thought must be given as to</span>
<span class="sd">        which model more accurately represents the specific scenario.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

        <span class="c1"># raise exception is the specified point pattern does not exist</span>
        <span class="k">if</span> <span class="n">sourcepattern</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available point patterns are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># calculate the network vertex to vertex distance matrix</span>
        <span class="c1"># if it is not already an attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;distance_matrix&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_distance_matrix</span><span class="p">(</span><span class="n">n_processes</span><span class="p">,</span> <span class="n">gen_tree</span><span class="o">=</span><span class="n">gen_tree</span><span class="p">)</span>

        <span class="c1"># determine if the source and destination patterns are equal</span>
        <span class="n">symmetric</span> <span class="o">=</span> <span class="n">sourcepattern</span> <span class="o">!=</span> <span class="n">destpattern</span>

        <span class="c1"># (for source-to-source patterns) if zero-distance neighbors are</span>
        <span class="c1"># desired, keep the diagonal as NaN and take the minimum</span>
        <span class="c1"># distance neighbor(s), which may include zero distance</span>
        <span class="c1"># neighors.</span>
        <span class="n">fill_diagonal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_zero_dist</span> <span class="ow">and</span> <span class="n">symmetric</span><span class="p">:</span>
            <span class="c1"># (for source-to-source patterns) if zero-distance neighbors</span>
            <span class="c1"># should be ignored, convert the diagonal to 0.0 and take</span>
            <span class="c1"># the minimum distance neighbor(s) that is/are not 0.0</span>
            <span class="c1"># distance.</span>
            <span class="n">fill_diagonal</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># set the source and destination observation point patterns</span>
        <span class="n">sourcepattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">sourcepattern</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">destpattern</span><span class="p">:</span>
            <span class="n">destpattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">destpattern</span><span class="p">]</span>

        <span class="c1"># if the full source to destination is not calculated,</span>
        <span class="c1"># do that at this time</span>
        <span class="k">if</span> <span class="n">all_dists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allneighbordistances</span><span class="p">(</span>
                <span class="n">sourcepattern</span><span class="p">,</span>
                <span class="n">destpattern</span><span class="o">=</span><span class="n">destpattern</span><span class="p">,</span>
                <span class="n">fill_diagonal</span><span class="o">=</span><span class="n">fill_diagonal</span><span class="p">,</span>
                <span class="n">n_processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">,</span>
                <span class="n">gen_tree</span><span class="o">=</span><span class="n">gen_tree</span><span class="p">,</span>
                <span class="n">snap_dist</span><span class="o">=</span><span class="n">snap_dist</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># create empty nearest neighbors lookup</span>
        <span class="n">nearest</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># iterate over each source point</span>
        <span class="k">for</span> <span class="n">source_index</span> <span class="ow">in</span> <span class="n">sourcepattern</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="c1"># this considers all zero-distance neighbors</span>
            <span class="k">if</span> <span class="n">keep_zero_dist</span> <span class="ow">and</span> <span class="n">symmetric</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">all_dists</span><span class="p">[</span><span class="n">source_index</span><span class="p">,</span> <span class="p">:])</span>

            <span class="c1"># this does not consider zero-distance neighbors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                    <span class="n">all_dists</span><span class="p">[</span><span class="n">source_index</span><span class="p">,</span> <span class="p">:][</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">all_dists</span><span class="p">[</span><span class="n">source_index</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="p">]</span>
                <span class="p">)</span>

            <span class="c1"># nearest destination (may be more than one if</span>
            <span class="c1"># observations are equal distances away)</span>
            <span class="n">dest_idxs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_dists</span><span class="p">[</span><span class="n">source_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">val</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># set nearest destination point(s) and distance</span>
            <span class="n">nearest</span><span class="p">[</span><span class="n">source_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dest_idxs</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nearest</span></div>


<div class="viewcode-block" id="Network.shortest_paths">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.shortest_paths">[docs]</a>
    <span class="k">def</span> <span class="nf">shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">pp_orig</span><span class="p">,</span> <span class="n">pp_dest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the shortest paths between observation points as</span>
<span class="sd">        ``libpysal.cg.Chain`` objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree : dict</span>
<span class="sd">            See ``tree_nearest`` in</span>
<span class="sd">            ``spaghetti.Network.allneighbordistances()``.</span>
<span class="sd">        pp_orig : str</span>
<span class="sd">            Origin point pattern for shortest paths.</span>
<span class="sd">            See ``name`` in ``spaghetti.Network.snapobservations()``.</span>
<span class="sd">        pp_dest : str</span>
<span class="sd">            Destination point pattern for shortest paths.</span>
<span class="sd">            See ``name`` in ``spaghetti.Network.snapobservations()``.</span>
<span class="sd">            Defaults ``pp_orig`` if not declared.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        paths : list</span>
<span class="sd">            The shortest paths between observations as geometric objects.</span>
<span class="sd">            Each element of the list is a list where the first element</span>
<span class="sd">            is an origin-destination pair tuple and the second</span>
<span class="sd">            element is a ``libpysal.cg.Chain``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            This exception is raised when an attempt to extract shortest</span>
<span class="sd">            path geometries is being made that but the ``network_trees``</span>
<span class="sd">            attribute does not exist within the network object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Instantiate a network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Snap observations to the network.</span>

<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(examples.get_path(&quot;schools.shp&quot;), &quot;schools&quot;)</span>

<span class="sd">        Create shortest path trees between observations.</span>

<span class="sd">        &gt;&gt;&gt; _, tree = ntw.allneighbordistances(&quot;schools&quot;, gen_tree=True)</span>

<span class="sd">        Generate geometric objects from trees.</span>

<span class="sd">        &gt;&gt;&gt; paths = ntw.shortest_paths(tree, &quot;schools&quot;)</span>

<span class="sd">        Extract the first path, which is between observations</span>
<span class="sd">        ``0`` and ``1``.</span>

<span class="sd">        &gt;&gt;&gt; path = paths[0]</span>
<span class="sd">        &gt;&gt;&gt; path[0]</span>
<span class="sd">        (0, 1)</span>

<span class="sd">        The are ``n`` vertices in the path between observations</span>
<span class="sd">        ``0`` and ``1``.</span>

<span class="sd">        &gt;&gt;&gt; n = len(path[1].vertices)</span>
<span class="sd">        &gt;&gt;&gt; n</span>
<span class="sd">        10</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># build the network trees object if it is not already an attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network_trees&quot;</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;The &#39;network_trees&#39; attribute has not been created. &quot;</span>
                <span class="s2">&quot;Rerun &#39;spaghetti.Network.allneighbordistances()&#39; &quot;</span>
                <span class="s2">&quot;with the &#39;gen_tree&#39; parameter set to &#39;True&#39;.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># isolate network attributes</span>
        <span class="n">pp_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">pp_orig</span><span class="p">]</span>
        <span class="n">pp_dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">pp_dest</span><span class="p">]</span> <span class="k">if</span> <span class="n">pp_dest</span> <span class="k">else</span> <span class="n">pp_orig</span>
        <span class="n">vtx_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span>
        <span class="n">net_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_trees</span>

        <span class="c1"># instantiate a list to store paths</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># iterate over each path in the tree</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">((</span><span class="n">obs0</span><span class="p">,</span> <span class="n">obs1</span><span class="p">),</span> <span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="c1"># if the observations share the same segment</span>
            <span class="c1"># create a partial segment path</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span> <span class="o">==</span> <span class="n">SAME_SEGMENT</span><span class="p">:</span>
                <span class="c1"># isolate the snapped coordinates and put in a list</span>
                <span class="n">partial_segment_verts</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cg</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pp_orig</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">obs0</span><span class="p">]),</span>
                    <span class="n">cg</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pp_dest</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">obs1</span><span class="p">]),</span>
                <span class="p">]</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">partial_segment_verts</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># source and destination network vertices</span>
                <span class="n">svtx</span><span class="p">,</span> <span class="n">dvtx</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">obs0</span><span class="p">,</span> <span class="n">obs1</span><span class="p">]</span>

                <span class="c1"># path passes through these nodes</span>
                <span class="c1"># (source and destination inclusive)</span>
                <span class="n">thru_nodes</span> <span class="o">=</span> <span class="n">net_trees</span><span class="p">[</span><span class="n">svtx</span><span class="p">][</span><span class="n">dvtx</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">dvtx</span><span class="p">]</span>

                <span class="c1"># full-length network segments along path</span>
                <span class="n">full_segs_path</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">iter_limit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thru_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">_idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">thru_nodes</span><span class="p">,</span> <span class="n">iter_limit</span><span class="p">)):</span>
                    <span class="n">full_segs_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">item</span><span class="p">,</span> <span class="n">thru_nodes</span><span class="p">[</span><span class="n">_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

                <span class="c1"># create copy of arc paths dataframe</span>
                <span class="n">full_segments</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fsp</span> <span class="ow">in</span> <span class="n">full_segs_path</span><span class="p">:</span>
                    <span class="n">full_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">_chain_constr</span><span class="p">(</span><span class="n">vtx_coords</span><span class="p">,</span> <span class="n">fsp</span><span class="p">))</span>

                <span class="c1"># unpack the vertices containers</span>
                <span class="n">segm_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">full_segments</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>

                <span class="c1"># remove duplicate vertices</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segm_verts</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">segm_verts</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="n">segm_verts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;list index out of range&quot;</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span>

                <span class="c1"># partial-length network segments along path</span>
                <span class="n">partial_segment_verts</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cg</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pp_orig</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">obs0</span><span class="p">]),</span>
                    <span class="n">cg</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pp_dest</span><span class="o">.</span><span class="n">snapped_coordinates</span><span class="p">[</span><span class="n">obs1</span><span class="p">]),</span>
                <span class="p">]</span>

                <span class="c1"># combine the full and partial segments into a single list</span>
                <span class="n">first_vtx</span><span class="p">,</span> <span class="n">last_vtx</span> <span class="o">=</span> <span class="n">partial_segment_verts</span>
                <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_vtx</span><span class="p">]</span> <span class="o">+</span> <span class="n">segm_verts</span> <span class="o">+</span> <span class="p">[</span><span class="n">last_vtx</span><span class="p">]</span>

            <span class="c1"># populate the ``paths`` dataframe</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">obs0</span><span class="p">,</span> <span class="n">obs1</span><span class="p">),</span> <span class="n">util</span><span class="o">.</span><span class="n">_chain_constr</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">paths</span></div>


<div class="viewcode-block" id="Network.split_arcs">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.split_arcs">[docs]</a>
    <span class="k">def</span> <span class="nf">split_arcs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">split_param</span><span class="p">,</span>
        <span class="n">split_by</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
        <span class="n">w_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">weights_kws</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>  <span class="c1"># noqa: B006, C408</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split all network arcs at either a fixed distance or fixed count.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_param : {int, float}</span>
<span class="sd">            Either the number of desired resultant split arcs or</span>
<span class="sd">            the distance at which arcs are split.</span>
<span class="sd">        split_by : str</span>
<span class="sd">            Either ``&#39;distance&#39;`` or ``&#39;count&#39;``. Default is ``&#39;distance&#39;``.</span>
<span class="sd">        w_components : bool</span>
<span class="sd">            Set to ``False`` to not record connected components from a</span>
<span class="sd">            ``libpysal.weights.W`` object. Default is ``True``.</span>
<span class="sd">        weights_kws : dict</span>
<span class="sd">            Keyword arguments for ``libpysal.weights.W``. Default is ``dict()``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        split_network : spaghetti.Network</span>
<span class="sd">            A newly instantiated ``spaghetti.Network`` object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Instantiate a network.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Split the network into a segments of 200 distance units in length</span>
<span class="sd">        (US feet in this case).</span>
<span class="sd">        This will include &quot;remainder&quot; segments unless the network is</span>
<span class="sd">        comprised of arcs with lengths exactly divisible by ``distance``.</span>

<span class="sd">        &gt;&gt;&gt; n200 = ntw.split_arcs(200.0)</span>
<span class="sd">        &gt;&gt;&gt; len(n200.arcs)</span>
<span class="sd">        688</span>

<span class="sd">        The number of arcs within the new object can be accessed via the</span>
<span class="sd">        weights object, as well. These counts will be equal.</span>

<span class="sd">        &gt;&gt;&gt; len(n200.arcs) == n200.w_network.n</span>
<span class="sd">        True</span>

<span class="sd">        Neighboring arcs can also be queried through the weight object.</span>

<span class="sd">        &gt;&gt;&gt; n200.w_network.neighbors[72,392]</span>
<span class="sd">        [(71, 72), (72, 252), (72, 391), (392, 393)]</span>

<span class="sd">        Network arcs can also be split by a specified number of divisions with</span>
<span class="sd">        the ``split_by`` keyword set to ``&#39;count&#39;``, which is ``&#39;distance&#39;`` by</span>
<span class="sd">        default. For example, each arc can be split into 2 equal parts.</span>

<span class="sd">        &gt;&gt;&gt; n2 = ntw.split_arcs(2, split_by=&quot;count&quot;)</span>
<span class="sd">        &gt;&gt;&gt; len(n2.arcs)</span>
<span class="sd">        606</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">int_coord</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;convert coordinates for integers if possible</span>
<span class="sd">            e.g., (1.0, 0.5) --&gt; (1, 0.5)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">is_integer</span><span class="p">())</span> <span class="k">else</span> <span class="n">c</span>

        <span class="c1"># catch invalid split types</span>
        <span class="n">_split_by</span> <span class="o">=</span> <span class="n">split_by</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">valid_split_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_split_by</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_split_types</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">split_by</span><span class="si">}</span><span class="s2">&#39; is not a valid value for &#39;split_by&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Valid arguments include: </span><span class="si">{</span><span class="n">valid_split_types</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># catch invalid count params</span>
        <span class="k">if</span> <span class="n">_split_by</span> <span class="o">==</span> <span class="s2">&quot;count&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">split_param</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Splitting arcs by 1 or less is not possible. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Currently &#39;split_param&#39; is set to </span><span class="si">{</span><span class="n">split_param</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">split_integer</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">split_param</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">split_param</span> <span class="o">!=</span> <span class="n">split_integer</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Network arcs must split by an integer. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Currently &#39;split_param&#39; is set to </span><span class="si">{</span><span class="n">split_param</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># create new shell network instance</span>
        <span class="n">split_network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>

        <span class="c1"># duplicate input network attributes</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arc_lengths</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_coords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_list</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">pointpatterns</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">in_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_data</span>

        <span class="c1"># set vertex ID to start iterations</span>
        <span class="n">current_vertex_id</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># instantiate sets for newly created network arcs and</span>
        <span class="c1"># input network arcs to remove</span>
        <span class="n">new_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">remove_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># iterate over all network arcs</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="p">:</span>
            <span class="c1"># fetch network arc length</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">split_network</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">arc</span><span class="p">]</span>

            <span class="c1"># set initial segmentation interval</span>
            <span class="k">if</span> <span class="n">_split_by</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
                <span class="n">interval</span> <span class="o">=</span> <span class="n">split_param</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interval</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">split_param</span><span class="p">)</span>

            <span class="c1"># initialize arc new arc length at zero</span>
            <span class="n">totallength</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># initialize the current vertex and ending vertex</span>
            <span class="n">currentstart</span><span class="p">,</span> <span class="n">end_vertex</span> <span class="o">=</span> <span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># determine direction of arc vertices</span>
            <span class="n">csx</span><span class="p">,</span> <span class="n">csy</span> <span class="o">=</span> <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">currentstart</span><span class="p">]</span>
            <span class="n">evx</span><span class="p">,</span> <span class="n">evy</span> <span class="o">=</span> <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">end_vertex</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">csy</span> <span class="o">&gt;</span> <span class="n">evy</span> <span class="ow">and</span> <span class="n">csx</span> <span class="o">==</span> <span class="n">evx</span><span class="p">:</span>
                <span class="n">currentstart</span><span class="p">,</span> <span class="n">end_vertex</span> <span class="o">=</span> <span class="n">end_vertex</span><span class="p">,</span> <span class="n">currentstart</span>

            <span class="c1"># if the arc will be split remove the current</span>
            <span class="c1"># arc from the adjacency list</span>
            <span class="k">if</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>
                <span class="c1"># remove old arc adjacency information</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">currentstart</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">end_vertex</span><span class="p">)</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">end_vertex</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">currentstart</span><span class="p">)</span>

                <span class="c1"># remove old arc length information</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">arc_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># add old arc to set of arcs to remove</span>
                <span class="n">remove_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span>

            <span class="c1"># if the arc will not be split, do nothing and continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># traverse the length of the arc</span>
            <span class="k">while</span> <span class="n">totallength</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>
                <span class="c1"># once an arc can not be split further</span>
                <span class="k">if</span> <span class="n">totallength</span> <span class="o">+</span> <span class="n">interval</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">:</span>
                    <span class="c1"># record the ending vertex</span>
                    <span class="n">currentstop</span> <span class="o">=</span> <span class="n">end_vertex</span>
                    <span class="c1"># set the length remainder</span>
                    <span class="n">interval</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">totallength</span>
                    <span class="c1"># full old length reached</span>
                    <span class="n">totallength</span> <span class="o">=</span> <span class="n">length</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># set the current vertex ID</span>
                    <span class="n">current_vertex_id</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># set the current stopping ID</span>
                    <span class="n">currentstop</span> <span class="o">=</span> <span class="n">current_vertex_id</span>
                    <span class="c1"># add the interval distance to the traversed length</span>
                    <span class="n">totallength</span> <span class="o">+=</span> <span class="n">interval</span>

                    <span class="c1"># compute the new vertex coordinate</span>
                    <span class="n">newx</span><span class="p">,</span> <span class="n">newy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newpoint_coords</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">totallength</span><span class="p">)</span>
                    <span class="n">new_vertex</span> <span class="o">=</span> <span class="p">(</span><span class="n">int_coord</span><span class="p">(</span><span class="n">newx</span><span class="p">),</span> <span class="n">int_coord</span><span class="p">(</span><span class="n">newy</span><span class="p">))</span>

                    <span class="c1"># update the vertex and coordinate info if needed</span>
                    <span class="k">if</span> <span class="n">new_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_network</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
                        <span class="n">split_network</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentstop</span>
                        <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">[</span><span class="n">currentstop</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vertex</span>
                        <span class="n">split_network</span><span class="o">.</span><span class="n">vertex_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentstop</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># retrieve vertex ID if coordinate already exists</span>
                        <span class="n">current_vertex_id</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">currentstop</span> <span class="o">=</span> <span class="n">split_network</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span>

                <span class="c1"># update the new network adjacency list</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">currentstart</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentstop</span><span class="p">)</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">[</span><span class="n">currentstop</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentstart</span><span class="p">)</span>

                <span class="c1"># add the new arc to the arc dictionary</span>
                <span class="c1"># iterating over this so we need to add after iterating</span>
                <span class="n">_new_arc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">currentstart</span><span class="p">,</span> <span class="n">currentstop</span><span class="p">]))</span>
                <span class="n">new_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_new_arc</span><span class="p">)</span>

                <span class="c1"># set the length of the arc</span>
                <span class="n">split_network</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">[</span><span class="n">_new_arc</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>

                <span class="c1"># increment the starting vertex to the stopping vertex</span>
                <span class="n">currentstart</span> <span class="o">=</span> <span class="n">currentstop</span>

        <span class="c1"># add the newly created arcs to the network and remove the old arcs</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_arcs</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">remove_arcs</span><span class="p">)</span>
        <span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">split_network</span><span class="o">.</span><span class="n">arcs</span><span class="p">)</span>

        <span class="c1"># extract connected components</span>
        <span class="k">if</span> <span class="n">w_components</span><span class="p">:</span>
            <span class="c1"># extract contiguity weights from libpysal</span>
            <span class="n">split_network</span><span class="o">.</span><span class="n">w_network</span> <span class="o">=</span> <span class="n">split_network</span><span class="o">.</span><span class="n">contiguityweights</span><span class="p">(</span>
                <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">from_split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weights_kws</span><span class="o">=</span><span class="n">weights_kws</span>
            <span class="p">)</span>
            <span class="c1"># identify connected components from the `w_network`</span>
            <span class="n">split_network</span><span class="o">.</span><span class="n">identify_components</span><span class="p">(</span><span class="n">split_network</span><span class="o">.</span><span class="n">w_network</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># update the snapped point pattern</span>
        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">split_network</span><span class="o">.</span><span class="n">pointpatterns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">split_network</span><span class="o">.</span><span class="n">_snap_to_link</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">split_network</span></div>


<div class="viewcode-block" id="Network.GlobalAutoK">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.GlobalAutoK">[docs]</a>
    <span class="k">def</span> <span class="nf">GlobalAutoK</span><span class="p">(</span>  <span class="c1"># noqa N802</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pointpattern</span><span class="p">,</span>
        <span class="n">nsteps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">distribution</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
        <span class="n">upperbound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute a global auto :math:`K`-function based on a network constrained</span>
<span class="sd">        cost matrix through</span>
<span class="sd">        `Monte Carlo simulation &lt;https://en.wikipedia.org/wiki/Monte_Carlo_method&gt;`_</span>
<span class="sd">        according to the formulation adapted from</span>
<span class="sd">        :cite:`doi:10.1002/9780470549094.ch5`. See the **Notes**</span>
<span class="sd">        section for further description.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pointpattern : spaghetti.PointPattern</span>
<span class="sd">            A ``spaghetti`` point pattern object.</span>
<span class="sd">        nsteps : int</span>
<span class="sd">            The number of steps at which the count of the nearest</span>
<span class="sd">            neighbors is computed. Default is ``10``.</span>
<span class="sd">        permutations : int</span>
<span class="sd">            The number of permutations to perform. Default is ``99``.</span>
<span class="sd">        threshold : float</span>
<span class="sd">            The level at which significance is computed.</span>
<span class="sd">            (0.5 would be 97.5% and 2.5%). Default is ``0.5``.</span>
<span class="sd">        distribution : str</span>
<span class="sd">            The distribution from which random points are sampled.</span>
<span class="sd">            Currently, the only supported distribution is ``&#39;uniform&#39;``.</span>
<span class="sd">        upperbound : float</span>
<span class="sd">            The upper bound at which the :math:`K`-function is computed.</span>
<span class="sd">            Defaults to the maximum observed nearest neighbor distance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GlobalAutoK : spaghetti.analysis.GlobalAutoK</span>
<span class="sd">            The global auto :math:`K`-function class instance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The :math:`K`-function can be formulated as:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \displaystyle K(r)=\frac{\sum^n_{i=1} \#[\hat{A} \in D(a_i, r)]}{n\lambda},</span>

<span class="sd">        where $n$ is the set cardinality of :math:`A`, :math:`\hat{A}` is the</span>
<span class="sd">        subset of observations in :math:`A` that are within :math:`D` units of</span>
<span class="sd">        distance from :math:`a_i` (each single observation in :math:`A`), and :math:`r`</span>
<span class="sd">        is the range of distance values over which the :math:`K`-function is</span>
<span class="sd">        calculated. The :math:`\lambda` term is the intensity of observations</span>
<span class="sd">        along the network, calculated as:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \displaystyle \lambda = \frac{n}{\big|N_{arcs}\big|},</span>

<span class="sd">        where :math:`\big|N_{arcs}\big|` is the summed length of network arcs.</span>
<span class="sd">        The global auto :math:`K`-function measures overall clustering in one set of</span>
<span class="sd">        observations by comparing all intra-set distances over a range of</span>
<span class="sd">        distance buffers :math:`D \in r`. The :math:`K`-function improves upon</span>
<span class="sd">        nearest-neighbor distance measures through the analysis of all neighbor</span>
<span class="sd">        distances. For an explanation on how to interpret the results of the</span>
<span class="sd">        :math:`K`-function see the Network Spatial Dependence tutorial</span>
<span class="sd">        `here &lt;https://pysal.org/spaghetti/notebooks/network-spatial-dependence.html&gt;`_.</span>

<span class="sd">        For original implementation see :cite:`Ripley1976`</span>
<span class="sd">        and :cite:`Ripley1977`.</span>
<span class="sd">        For further Network-`K` formulations see</span>
<span class="sd">        :cite:`doi:10.1111/j.1538-4632.2001.tb00448.x`,</span>
<span class="sd">        :cite:`doi:10.1002/9781119967101.ch6`, and</span>
<span class="sd">        :cite:`Baddeley2020`.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        pointpats.K</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a network instance.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(in_data=examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Snap observation points onto the network.</span>

<span class="sd">        &gt;&gt;&gt; pt_str = &quot;schools&quot;</span>
<span class="sd">        &gt;&gt;&gt; in_data = examples.get_path(pt_str+&quot;.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(in_data, pt_str, attribute=True)</span>
<span class="sd">        &gt;&gt;&gt; schools = ntw.pointpatterns[pt_str]</span>

<span class="sd">        Compute a :math:`K`-function from school observations</span>
<span class="sd">        with ``99`` ``permutations`` at ``10`` intervals.</span>

<span class="sd">        &gt;&gt;&gt; kres = ntw.GlobalAutoK(schools, permutations=99, nsteps=10)</span>
<span class="sd">        &gt;&gt;&gt; kres.lowerenvelope.shape[0]</span>
<span class="sd">        10</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call analysis.GlobalAutoK</span>
        <span class="k">return</span> <span class="n">GlobalAutoK</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">pointpattern</span><span class="p">,</span>
            <span class="n">nsteps</span><span class="o">=</span><span class="n">nsteps</span><span class="p">,</span>
            <span class="n">permutations</span><span class="o">=</span><span class="n">permutations</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">distribution</span><span class="o">=</span><span class="n">distribution</span><span class="p">,</span>
            <span class="n">upperbound</span><span class="o">=</span><span class="n">upperbound</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Network.Moran">
<a class="viewcode-back" href="../../generated/spaghetti.Network.html#spaghetti.Network.Moran">[docs]</a>
    <span class="k">def</span> <span class="nf">Moran</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pp_name</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># noqa N802</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate a Moran&#39;s *I* statistic on a set of observations</span>
<span class="sd">        based on network arcs. The Moranâ€™s *I* test statistic allows</span>
<span class="sd">        for the inference of how clustered (or dispersed) a dataset is</span>
<span class="sd">        while considering both attribute values and spatial relationships.</span>
<span class="sd">        A value of closer to +1 indicates absolute clustering while a</span>
<span class="sd">        value of closer to -1 indicates absolute dispersion. Complete</span>
<span class="sd">        spatial randomness takes the value of 0. See the ``esda``</span>
<span class="sd">        `documentation &lt;https://pysal.org/esda/generated/esda.Moran.html#esda.Moran&gt;`_</span>
<span class="sd">        for in-depth descriptions and tutorials.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pp_name : str</span>
<span class="sd">            The name of the point pattern in question.</span>
<span class="sd">        permutations : int</span>
<span class="sd">            The number of permutations to perform. Default is ``999``.</span>
<span class="sd">        graph : bool</span>
<span class="sd">            Perform the Moran calculation on the graph `W` object</span>
<span class="sd">            (``True``). Default is ``False``, which performs the</span>
<span class="sd">            Moran calculation on the network `W` object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moran : esda.Moran</span>
<span class="sd">            A Moran&#39;s *I* statistic object results.</span>
<span class="sd">        y : list</span>
<span class="sd">            The y-axis (counts).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a network instance.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(in_data=examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Snap observation points onto the network.</span>

<span class="sd">        &gt;&gt;&gt; crimes = &quot;crimes&quot;</span>
<span class="sd">        &gt;&gt;&gt; in_data = examples.get_path(crimes+&quot;.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ntw.snapobservations(in_data, crimes, attribute=True)</span>

<span class="sd">        Compute a Moran&#39;s :math:`I` from crime observations.</span>

<span class="sd">        &gt;&gt;&gt; moran_res, _ = ntw.Moran(crimes)</span>
<span class="sd">        &gt;&gt;&gt; round(moran_res.I, 6)</span>
<span class="sd">        np.float64(0.005193)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        See :cite:`moran:_cliff81` and :cite:`esda:_2019` for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set proper weights attribute</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_graph</span> <span class="k">if</span> <span class="n">graph</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_network</span>

        <span class="c1"># Compute the counts</span>
        <span class="n">pointpat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpatterns</span><span class="p">[</span><span class="n">pp_name</span><span class="p">]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_per_link</span><span class="p">(</span><span class="n">pointpat</span><span class="o">.</span><span class="n">obs_to_arc</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>

        <span class="c1"># Build the y vector</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">neighbors</span><span class="p">]</span>

        <span class="c1"># Moran&#39;s I</span>
        <span class="n">moran</span> <span class="o">=</span> <span class="n">esda</span><span class="o">.</span><span class="n">moran</span><span class="o">.</span><span class="n">Moran</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="n">permutations</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">moran</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="Network.savenetwork">
<a class="viewcode-back" href="../../generated/spaghetti.network.Network.savenetwork.html#spaghetti.Network.savenetwork">[docs]</a>
    <span class="k">def</span> <span class="nf">savenetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save a network to disk as a binary file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            The filename where the network should be saved. This should</span>
<span class="sd">            be a full path or it will be saved in the current directory.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a network instance.</span>

<span class="sd">        &gt;&gt;&gt; import spaghetti</span>
<span class="sd">        &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">        &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">        Save out the network instance.</span>

<span class="sd">        &gt;&gt;&gt; ntw.savenetwork(&quot;mynetwork.pkl&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">_open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">networkout</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">networkout</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Network.loadnetwork">
<a class="viewcode-back" href="../../generated/spaghetti.network.Network.loadnetwork.html#spaghetti.Network.loadnetwork">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">loadnetwork</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load a network from a binary file saved on disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            The filename where the network is saved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : spaghetti.Network</span>
<span class="sd">            A pre-computed ``spaghetti`` network object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">_open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">networkin</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">networkin</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="extract_component">
<a class="viewcode-back" href="../../generated/spaghetti.extract_component.html#spaghetti.extract_component">[docs]</a>
<span class="k">def</span> <span class="nf">extract_component</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">weightings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a single component from a network object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net : spaghetti.Network</span>
<span class="sd">        Full network object.</span>
<span class="sd">    component_id : int</span>
<span class="sd">        The ID of the desired network component.</span>
<span class="sd">    weightings : {dict, bool}</span>
<span class="sd">        See the ``weightings`` keyword argument in ``spaghetti.Network``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cnet : spaghetti.Network</span>
<span class="sd">        The pruned network containing the component specified in</span>
<span class="sd">        ``component_id``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Point patterns are not reassigned when extracting a component. Therefore,</span>
<span class="sd">    component extraction should be performed prior to snapping any point</span>
<span class="sd">    sets onto the network. Also, if the ``spaghetti.Network`` object</span>
<span class="sd">    has ``distance_matrix`` or ``network_trees`` attributes, they are</span>
<span class="sd">    deleted and must be computed again on the single component.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Instantiate a network object.</span>

<span class="sd">    &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">    &gt;&gt;&gt; import spaghetti</span>
<span class="sd">    &gt;&gt;&gt; snow_net = examples.get_path(&quot;Soho_Network.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ntw = spaghetti.Network(</span>
<span class="sd">    ...     in_data=snow_net,</span>
<span class="sd">    ...     extractgraph=False,</span>
<span class="sd">    ...     weights_kws=dict(silence_warnings=True)</span>
<span class="sd">    ... )</span>

<span class="sd">    The network is not fully connected.</span>

<span class="sd">    &gt;&gt;&gt; ntw.network_fully_connected</span>
<span class="sd">    False</span>

<span class="sd">    Examine the number of network components.</span>

<span class="sd">    &gt;&gt;&gt; ntw.network_n_components</span>
<span class="sd">    45</span>

<span class="sd">    Extract the longest component.</span>

<span class="sd">    &gt;&gt;&gt; longest = spaghetti.extract_component(ntw, ntw.network_longest_component)</span>
<span class="sd">    &gt;&gt;&gt; longest.network_n_components</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; longest.network_component_lengths</span>
<span class="sd">    {np.int32(0): 13508.169276875526}</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_reassign</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">cid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper for reassigning attributes.&quot;&quot;&quot;</span>

        <span class="c1"># set for each attribute(s)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_fully_connected&quot;</span><span class="p">:</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">objt</span> <span class="o">+</span> <span class="n">attr</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_n_components&quot;</span><span class="p">:</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">objt</span> <span class="o">+</span> <span class="n">attr</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_longest_component&quot;</span><span class="p">,</span> <span class="s2">&quot;_largest_component&quot;</span><span class="p">]:</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">cid</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">objt</span> <span class="o">+</span> <span class="n">attr</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;vertex_list&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns vertex list + network, graph component vertices</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="p">[</span><span class="n">objt</span> <span class="o">+</span> <span class="s2">&quot;_component_vertices&quot;</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">supp</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="n">cid</span><span class="p">]]</span>
            <span class="n">_val</span> <span class="o">+=</span> <span class="p">[{</span><span class="n">cid</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="n">cid</span><span class="p">]}</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">+</span> <span class="n">supp</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;vertex_coords&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns both vertex_coords and vertices</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="s2">&quot;vertex_list&quot;</span><span class="p">)</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">supp</span><span class="p">}]</span>
            <span class="n">_val</span> <span class="o">+=</span> <span class="p">[{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span><span class="p">,</span> <span class="s2">&quot;vertices&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_component_vertex_count&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns both network and graph _component_vertex_count</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="s2">&quot;vertex_list&quot;</span><span class="p">))</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[{</span><span class="n">cid</span><span class="p">:</span> <span class="n">supp</span><span class="p">}</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">objt</span> <span class="o">+</span> <span class="n">attr</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;adjacencylist&quot;</span><span class="p">:</span>
            <span class="n">supp_adj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">supp_vtx</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="s2">&quot;vertex_list&quot;</span><span class="p">)</span>
            <span class="n">supp_rmv</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">supp_adj</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supp_vtx</span><span class="p">]</span>
            <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp_rmv</span><span class="p">]</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_component_is_ring&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns both network and graph _component_is_ring</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">objt</span> <span class="o">+</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[{</span><span class="n">cid</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="n">cid</span><span class="p">]}</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">objt</span> <span class="o">+</span> <span class="n">attr</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;non_articulation_points&quot;</span><span class="p">:</span>
            <span class="n">supp_vtx</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="s2">&quot;vertex_list&quot;</span><span class="p">)</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp_vtx</span><span class="p">]]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_component2&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns both network and graph _component2 attributes</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="p">[</span><span class="n">_n</span> <span class="o">+</span> <span class="s2">&quot;_component2&quot;</span> <span class="o">+</span> <span class="n">_a</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">hasgraph</span><span class="p">:</span>
                <span class="n">supp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_g</span> <span class="o">+</span> <span class="s2">&quot;_component2&quot;</span> <span class="o">+</span> <span class="n">_e</span><span class="p">]</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[{</span><span class="n">cid</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="n">cid</span><span class="p">]}</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">supp</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;arcs&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns both arcs and edges</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="s2">&quot;_component2&quot;</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="p">[</span><span class="n">_n</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">+</span> <span class="n">_a</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">hasgraph</span><span class="p">:</span>
                <span class="n">supp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_g</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">+</span> <span class="n">_e</span><span class="p">]</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="n">cid</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">hasgraph</span><span class="p">:</span>
                <span class="n">attr</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_component_labels&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns both network and graph _component_labels</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">o</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cid</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">objt</span> <span class="o">+</span> <span class="n">attr</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_component_lengths&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns both network and graph _component_lengths</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="p">[</span><span class="n">objt</span> <span class="o">+</span> <span class="n">attr</span> <span class="k">for</span> <span class="n">objt</span> <span class="ow">in</span> <span class="n">obj_type</span><span class="p">]</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[{</span><span class="n">cid</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="n">cid</span><span class="p">]}</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">supp</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_lengths&quot;</span><span class="p">:</span>
            <span class="c1"># reassigns both arc and edge _lengths</span>
            <span class="n">supp_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="o">+</span> <span class="n">attr</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
            <span class="n">supp_lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">supp_name</span><span class="p">]</span>
            <span class="n">supp_link</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">o</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
            <span class="n">supp_ll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">supp_lens</span><span class="p">,</span> <span class="n">supp_link</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l1</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l2</span><span class="p">}</span> <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">supp_ll</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">supp_name</span>

        <span class="c1"># reassign attributes</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">av</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">_val</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">av</span><span class="p">)</span>

    <span class="c1"># provide warning (for now) if the network contains a point pattern</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s2">&quot;pointpatterns&quot;</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;There is a least one point pattern associated with the network.&quot;</span>
            <span class="s2">&quot; Component extraction should be performed prior to snapping&quot;</span>
            <span class="s2">&quot; point patterns to the network object; failing to do so may&quot;</span>
            <span class="s2">&quot; lead to unexpected results.&quot;</span>
        <span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># provide warning (for now) if the network contains a point pattern</span>
    <span class="n">dm</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="s2">&quot;distance_matrix&quot;</span><span class="p">,</span> <span class="s2">&quot;network_trees&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Either one or both (</span><span class="si">{</span><span class="n">dm</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">nt</span><span class="si">}</span><span class="s2">) attributes&quot;</span>
            <span class="s2">&quot; are present and will be deleted. These must be&quot;</span>
            <span class="s2">&quot; recalculated following component extraction.&quot;</span>
        <span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">dm</span><span class="p">,</span> <span class="n">nt</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="c1"># make initial copy of the network</span>
    <span class="n">cnet</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>

    <span class="c1"># set labels</span>
    <span class="n">_n</span><span class="p">,</span> <span class="n">_a</span><span class="p">,</span> <span class="n">_g</span><span class="p">,</span> <span class="n">_e</span> <span class="o">=</span> <span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;arc&quot;</span><span class="p">,</span> <span class="s2">&quot;graph&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span>
    <span class="n">obj_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">_n</span><span class="p">]</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">_a</span><span class="p">]</span>
    <span class="n">hasgraph</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="s2">&quot;w_graph&quot;</span><span class="p">):</span>
        <span class="n">obj_type</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_g</span><span class="p">]</span>
        <span class="n">obj</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_e</span><span class="p">]</span>
        <span class="n">hasgraph</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># attributes to reassign</span>
    <span class="n">update_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_fully_connected&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_n_components&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_longest_component&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_largest_component&quot;</span><span class="p">,</span>
        <span class="s2">&quot;vertex_list&quot;</span><span class="p">,</span>
        <span class="s2">&quot;vertex_coords&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_component_vertex_count&quot;</span><span class="p">,</span>
        <span class="s2">&quot;adjacencylist&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_component_is_ring&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_component2&quot;</span><span class="p">,</span>
        <span class="s2">&quot;arcs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_component_lengths&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lengths&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_component_labels&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">hasgraph</span><span class="p">:</span>
        <span class="n">update_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;non_articulation_points&quot;</span><span class="p">)</span>

    <span class="c1"># reassign attributes</span>
    <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">update_attributes</span><span class="p">:</span>
        <span class="n">_reassign</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">component_id</span><span class="p">)</span>

    <span class="c1"># recreate spatial weights</span>
    <span class="n">cnet</span><span class="o">.</span><span class="n">w_network</span> <span class="o">=</span> <span class="n">cnet</span><span class="o">.</span><span class="n">contiguityweights</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weightings</span><span class="o">=</span><span class="n">weightings</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hasgraph</span><span class="p">:</span>
        <span class="n">cnet</span><span class="o">.</span><span class="n">w_graph</span> <span class="o">=</span> <span class="n">cnet</span><span class="o">.</span><span class="n">contiguityweights</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weightings</span><span class="o">=</span><span class="n">weightings</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cnet</span></div>



<div class="viewcode-block" id="spanning_tree">
<a class="viewcode-back" href="../../generated/spaghetti.spanning_tree.html#spaghetti.spanning_tree">[docs]</a>
<span class="k">def</span> <span class="nf">spanning_tree</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="n">maximum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">silence_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a minimum or maximum spanning tree from a network.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net : spaghetti.Network</span>
<span class="sd">        Instance of a network object.</span>
<span class="sd">    method : str</span>
<span class="sd">        Method for determining spanning tree. Currently, the only</span>
<span class="sd">        supported method is &#39;sort&#39;, which sorts the network arcs</span>
<span class="sd">        by length prior to building intermediary networks and checking</span>
<span class="sd">        for cycles within the tree/subtrees. Future methods may</span>
<span class="sd">        include linear programming approachs, etc.</span>
<span class="sd">    maximum : bool</span>
<span class="sd">        When ``True`` a maximum spanning tree is created. When ``False``</span>
<span class="sd">        a minimum spanning tree is created. Default is ``False``.</span>
<span class="sd">    silence_warnings : bool</span>
<span class="sd">        Warn if there is more than one connected component. Default is</span>
<span class="sd">        ``False`` due to the nature of constructing a minimum</span>
<span class="sd">        spanning tree.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    net : spaghetti.Network</span>
<span class="sd">        Pruned instance of the network object.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    For in-depth background and details see</span>
<span class="sd">    :cite:`GrahamHell_1985`,</span>
<span class="sd">    :cite:`AhujaRavindraK`, and</span>
<span class="sd">    :cite:`Okabe2012`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>

<span class="sd">    networkx.algorithms.tree.mst</span>
<span class="sd">    scipy.sparse.csgraph.minimum_spanning_tree</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create a network instance.</span>

<span class="sd">    &gt;&gt;&gt; from libpysal import cg</span>
<span class="sd">    &gt;&gt;&gt; import spaghetti</span>
<span class="sd">    &gt;&gt;&gt; p00 = cg.Point((0,0))</span>
<span class="sd">    &gt;&gt;&gt; lines = [cg.Chain([p00, cg.Point((0,3)), cg.Point((4,0)), p00])]</span>
<span class="sd">    &gt;&gt;&gt; ntw = spaghetti.Network(in_data=lines)</span>

<span class="sd">    Extract the minimum spanning tree.</span>

<span class="sd">    &gt;&gt;&gt; minst_net = spaghetti.spanning_tree(ntw)</span>
<span class="sd">    &gt;&gt;&gt; min_len = sum(minst_net.arc_lengths.values())</span>
<span class="sd">    &gt;&gt;&gt; min_len</span>
<span class="sd">    7.0</span>

<span class="sd">    Extract the maximum spanning tree.</span>

<span class="sd">    &gt;&gt;&gt; maxst_net = spaghetti.spanning_tree(ntw, maximum=True)</span>
<span class="sd">    &gt;&gt;&gt; max_len = sum(maxst_net.arc_lengths.values())</span>
<span class="sd">    &gt;&gt;&gt; max_len</span>
<span class="sd">    9.0</span>

<span class="sd">    &gt;&gt;&gt; max_len &gt; min_len</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># (un)silence warning</span>
    <span class="n">weights_kws</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;silence_warnings&quot;</span><span class="p">:</span> <span class="n">silence_warnings</span><span class="p">}</span>
    <span class="c1"># do not extract graph object while testing for cycles</span>
    <span class="n">net_kws</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;extractgraph&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;weights_kws&quot;</span><span class="p">:</span> <span class="n">weights_kws</span><span class="p">}</span>

    <span class="c1"># if the network has no cycles, it is already a spanning tree</span>
    <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">network_has_cycle</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;sort&quot;</span><span class="p">:</span>
            <span class="n">spanning_tree</span> <span class="o">=</span> <span class="n">mst_weighted_sort</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">net_kws</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; not a valid method for minimum spanning tree creation.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># instantiate the spanning tree as a network object</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="n">in_data</span><span class="o">=</span><span class="n">spanning_tree</span><span class="p">,</span> <span class="n">weights_kws</span><span class="o">=</span><span class="n">weights_kws</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">net</span></div>



<span class="k">def</span> <span class="nf">mst_weighted_sort</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">net_kws</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a minimum or maximum spanning tree from a network used</span>
<span class="sd">    the length-weighted sort method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net : spaghetti.Network</span>
<span class="sd">        See ``spanning_tree()``.</span>
<span class="sd">    maximum : bool</span>
<span class="sd">        See ``spanning_tree()``.</span>
<span class="sd">    net_kws : dict</span>
<span class="sd">        Keywords arguments for instaniating a ``spaghetti.Network``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spanning_tree : list</span>
<span class="sd">        All networks arcs that are members of the spanning tree.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    This function is based on the method found in Chapter 3</span>
<span class="sd">    Section 4.3 of :cite:`Okabe2012`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># network arcs dictionary sorted by arc length</span>
    <span class="n">sort_kws</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">net</span><span class="o">.</span><span class="n">arc_lengths</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="s2">&quot;reverse&quot;</span><span class="p">:</span> <span class="n">maximum</span><span class="p">}</span>
    <span class="n">sorted_lengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">arc_lengths</span><span class="p">,</span> <span class="o">**</span><span class="n">sort_kws</span><span class="p">)</span>

    <span class="c1"># the spanning tree is initially empty</span>
    <span class="n">spanning_tree</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># iterate over each lengths of network arc</span>
    <span class="k">while</span> <span class="n">sorted_lengths</span><span class="p">:</span>
        <span class="n">_arc</span> <span class="o">=</span> <span class="n">sorted_lengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># make a spatial representation of an arc</span>
        <span class="n">chain_rep</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">chain_constr</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">vertex_coords</span><span class="p">,</span> <span class="p">[</span><span class="n">_arc</span><span class="p">])</span>
        <span class="c1"># current set of network arcs as libpysal.cg.Chain</span>
        <span class="n">_chains</span> <span class="o">=</span> <span class="n">spanning_tree</span> <span class="o">+</span> <span class="n">chain_rep</span>
        <span class="c1"># current network iteration</span>
        <span class="n">_ntw</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="n">in_data</span><span class="o">=</span><span class="n">_chains</span><span class="p">,</span> <span class="o">**</span><span class="n">net_kws</span><span class="p">)</span>
        <span class="c1"># determine if the network contains a cycle</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">util</span><span class="o">.</span><span class="n">network_has_cycle</span><span class="p">(</span><span class="n">_ntw</span><span class="o">.</span><span class="n">adjacencylist</span><span class="p">):</span>
            <span class="c1"># If no cycle is present, add the arc to the spanning tree</span>
            <span class="n">spanning_tree</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain_rep</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spanning_tree</span>


<div class="viewcode-block" id="element_as_gdf">
<a class="viewcode-back" href="../../generated/spaghetti.element_as_gdf.html#spaghetti.element_as_gdf">[docs]</a>
<span class="k">def</span> <span class="nf">element_as_gdf</span><span class="p">(</span>
    <span class="n">net</span><span class="p">,</span>
    <span class="n">vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">arcs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">pp_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">snapped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">routes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_col</span><span class="o">=</span><span class="s2">&quot;id&quot;</span><span class="p">,</span>
    <span class="n">geom_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a ``geopandas.GeoDataFrame`` of network elements. This can be</span>
<span class="sd">    (a) the vertices of a network; (b) the arcs of a network; (c) both the</span>
<span class="sd">    vertices and arcs of the network; (d) the raw point pattern associated</span>
<span class="sd">    with the network; (e) the snapped point pattern of (d); or (f) the</span>
<span class="sd">    shortest path routes between point observations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net : spaghetti.Network</span>
<span class="sd">        A `spaghetti` network object.</span>
<span class="sd">    vertices : bool</span>
<span class="sd">        Extract the network vertices (``True``). Default is ``False``.</span>
<span class="sd">    arcs : bool</span>
<span class="sd">        Extract the network arcs (``True``). Default is ``False``.</span>
<span class="sd">    pp_name : str</span>
<span class="sd">        Name of the ``network.PointPattern`` to extract.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    snapped : bool</span>
<span class="sd">        If extracting a ``network.PointPattern``, set to ``True`` for</span>
<span class="sd">        snapped point locations along the network. Default is ``False``.</span>
<span class="sd">    routes : dict</span>
<span class="sd">        See ``paths`` from ``spaghetti.Network.shortest_paths``.</span>
<span class="sd">        Default is ``None``.</span>
<span class="sd">    id_col : str</span>
<span class="sd">        ``geopandas.GeoDataFrame`` column name for IDs. Default is ``&quot;id&quot;``.</span>
<span class="sd">        When extracting routes this creates an (origin, destination) tuple.</span>
<span class="sd">    geom_col : str</span>
<span class="sd">        Deprecated and will be removed in the minor release.</span>
<span class="sd">        ``geopandas.GeoDataFrame`` column name for IDs. Default is ``&quot;id&quot;``.</span>
<span class="sd">        When extracting routes this creates an (origin, destination) tuple.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    KeyError</span>
<span class="sd">        In order to extract a ``network.PointPattern`` it must already</span>
<span class="sd">        be a part of the network object. This exception is raised</span>
<span class="sd">        when a ``network.PointPattern`` is being extracted that does</span>
<span class="sd">        not exist within the network object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    points : geopandas.GeoDataFrame</span>
<span class="sd">        Network point elements (either vertices or ``network.PointPattern``</span>
<span class="sd">        points) as a ``geopandas.GeoDataFrame`` of ``shapely.geometry.Point``</span>
<span class="sd">        objects with an ``&quot;id&quot;`` column and ``&quot;geometry&quot;&quot;`` column.</span>
<span class="sd">        If the network object has a ``network_component_vertices`` attribute,</span>
<span class="sd">        then component labels are also added in a column.</span>
<span class="sd">    lines : geopandas.GeoDataFrame</span>
<span class="sd">        Network arc elements as a ``geopandas.GeoDataFrame`` of</span>
<span class="sd">        ``shapely.geometry.LineString`` objects with an ``&quot;id&quot;``</span>
<span class="sd">        column and ``&quot;geometry&quot;`` column. If the network object has</span>
<span class="sd">        a ``network_component_labels`` attribute, then component labels</span>
<span class="sd">        are also added in a column.</span>
<span class="sd">    paths : geopandas.GeoDataFrame</span>
<span class="sd">        Shortest path routes along network arc elements as a</span>
<span class="sd">        ``geopandas.GeoDataFrame`` of ``shapely.geometry.LineString``</span>
<span class="sd">        objects with an ``&quot;id&quot;`` (see ``spaghetti.Network.shortest_paths()``)</span>
<span class="sd">        column and ``&quot;geometry&quot;`` column.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    When both network vertices and arcs are desired, the variable</span>
<span class="sd">    declaration must be in the order: &lt;vertices&gt;, &lt;arcs&gt;.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>

<span class="sd">    geopandas.GeoDataFrame</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Instantiate a network object.</span>

<span class="sd">    &gt;&gt;&gt; import spaghetti</span>
<span class="sd">    &gt;&gt;&gt; from libpysal import examples</span>
<span class="sd">    &gt;&gt;&gt; ntw = spaghetti.Network(examples.get_path(&quot;streets.shp&quot;))</span>

<span class="sd">    Extract the network elements (vertices and arcs) as</span>
<span class="sd">    ``geopandas.GeoDataFrame`` objects.</span>

<span class="sd">    &gt;&gt;&gt; vertices_df, arcs_df = spaghetti.element_as_gdf(</span>
<span class="sd">    ...     ntw, vertices=True, arcs=True</span>
<span class="sd">    ... )</span>

<span class="sd">    Examine the first vertex. It is a member of the component labeled ``0``.</span>

<span class="sd">    &gt;&gt;&gt; vertices_df.loc[0]</span>
<span class="sd">    id                                            0</span>
<span class="sd">    geometry      POINT (728368.04762 877125.89535)</span>
<span class="sd">    comp_label                                    0</span>
<span class="sd">    Name: 0, dtype: object</span>

<span class="sd">    Calculate the total length of the network.</span>

<span class="sd">    &gt;&gt;&gt; arcs_df.geometry.length.sum()</span>
<span class="sd">    np.float64(104414.09200823458)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># see GH#722</span>
    <span class="k">if</span> <span class="n">geom_col</span><span class="p">:</span>
        <span class="n">dep_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;The ``geom_col`` keyword argument is deprecated and will &quot;</span>
            <span class="s2">&quot;be dropped in the next minor release of pysal/spaghetti (1.8.0) &quot;</span>
            <span class="s2">&quot;in favor of the default &#39;geometry&#39; name. Users can rename &quot;</span>
            <span class="s2">&quot;the geometry column following processing, if desired.&quot;</span>
        <span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">dep_msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># shortest path routes between observations</span>
    <span class="k">if</span> <span class="n">routes</span><span class="p">:</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">_routes_as_gdf</span><span class="p">(</span><span class="n">routes</span><span class="p">,</span> <span class="n">id_col</span><span class="p">)</span>
        <span class="c1"># see GH#722</span>
        <span class="k">if</span> <span class="n">geom_col</span><span class="p">:</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">rename_geometry</span><span class="p">(</span><span class="n">geom_col</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span>

    <span class="c1"># need vertices place holder to create network segment LineStrings</span>
    <span class="c1"># even if only network edges are desired.</span>
    <span class="n">vertices_for_arcs</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">arcs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">vertices_for_arcs</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># vertices/nodes/points</span>
    <span class="k">if</span> <span class="n">vertices</span> <span class="ow">or</span> <span class="n">vertices_for_arcs</span> <span class="ow">or</span> <span class="n">pp_name</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">_points_as_gdf</span><span class="p">(</span>
            <span class="n">net</span><span class="p">,</span>
            <span class="n">vertices</span><span class="p">,</span>
            <span class="n">vertices_for_arcs</span><span class="p">,</span>
            <span class="n">pp_name</span><span class="p">,</span>
            <span class="n">snapped</span><span class="p">,</span>
            <span class="n">id_col</span><span class="o">=</span><span class="n">id_col</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># return points geodataframe if arcs not specified or</span>
        <span class="c1"># if extracting `PointPattern` points</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arcs</span> <span class="ow">or</span> <span class="n">pp_name</span><span class="p">:</span>
            <span class="c1"># see GH#722</span>
            <span class="k">if</span> <span class="n">geom_col</span><span class="p">:</span>
                <span class="n">points</span><span class="o">.</span><span class="n">rename_geometry</span><span class="p">(</span><span class="n">geom_col</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">points</span>

    <span class="c1"># arcs</span>
    <span class="n">arcs</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">_arcs_as_gdf</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">id_col</span><span class="o">=</span><span class="n">id_col</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">vertices_for_arcs</span><span class="p">:</span>
        <span class="c1"># see GH#722</span>
        <span class="k">if</span> <span class="n">geom_col</span><span class="p">:</span>
            <span class="n">arcs</span><span class="o">.</span><span class="n">rename_geometry</span><span class="p">(</span><span class="n">geom_col</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arcs</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># see GH#722</span>
        <span class="k">if</span> <span class="n">geom_col</span><span class="p">:</span>
            <span class="n">points</span><span class="o">.</span><span class="n">rename_geometry</span><span class="p">(</span><span class="n">geom_col</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">arcs</span><span class="o">.</span><span class="n">rename_geometry</span><span class="p">(</span><span class="n">geom_col</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">arcs</span></div>



<div class="viewcode-block" id="regular_lattice">
<a class="viewcode-back" href="../../generated/spaghetti.regular_lattice.html#spaghetti.regular_lattice">[docs]</a>
<span class="k">def</span> <span class="nf">regular_lattice</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">nh</span><span class="p">,</span> <span class="n">nv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exterior</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a regular lattice of line segments (``libpysal.cg.Chain``</span>
<span class="sd">    `objects &lt;https://pysal.org/libpysal/generated/libpysal.cg.Chain.html&gt;`_).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bounds : {tuple, list}</span>
<span class="sd">        Area bounds in the form - &lt;minx,miny,maxx,maxy&gt;.</span>
<span class="sd">    nh : int</span>
<span class="sd">        The number of internal horizontal lines of the lattice.</span>
<span class="sd">    nv : int</span>
<span class="sd">        The number of internal vertical lines of the lattice. Defaults to</span>
<span class="sd">        ``nh`` if left as None.</span>
<span class="sd">    exterior : bool</span>
<span class="sd">        Flag for including the outer bounding box segments. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lattice : list</span>
<span class="sd">        The ``libpysal.cg.Chain`` objects forming a regular lattice.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The ``nh`` and ``nv`` parameters do not include the external</span>
<span class="sd">    line segments. For example, setting ``nh=3, nv=2, exterior=True``</span>
<span class="sd">    will result in 5 horizontal line sets and 4 vertical line sets.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create a 5x5 regular lattice with an exterior</span>

<span class="sd">    &gt;&gt;&gt; import spaghetti</span>
<span class="sd">    &gt;&gt;&gt; lattice = spaghetti.regular_lattice((0,0,4,4), 3, exterior=True)</span>
<span class="sd">    &gt;&gt;&gt; lattice[0].vertices</span>
<span class="sd">    [(0.0, 0.0), (1.0, 0.0)]</span>

<span class="sd">    Create a 5x5 regular lattice without an exterior</span>

<span class="sd">    &gt;&gt;&gt; lattice = spaghetti.regular_lattice((0,0,5,5), 3, exterior=False)</span>
<span class="sd">    &gt;&gt;&gt; lattice[-1].vertices</span>
<span class="sd">    [(3.75, 3.75), (3.75, 5.0)]</span>

<span class="sd">    Create a 7x9 regular lattice with an exterior from the</span>
<span class="sd">    bounds of ``streets.shp``.</span>

<span class="sd">    &gt;&gt;&gt; path = libpysal.examples.get_path(&quot;streets.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; shp = libpysal.io.open(path)</span>
<span class="sd">    &gt;&gt;&gt; lattice = spaghetti.regular_lattice(shp.bbox, 5, nv=7, exterior=True)</span>
<span class="sd">    &gt;&gt;&gt; lattice[0].vertices</span>
<span class="sd">    [(723414.3683108028, 875929.0396895551), (724286.1381211297, 875929.0396895551)]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check for bounds validity</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The &#39;bounds&#39; parameter is </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span><span class="si">}</span><span class="s2"> elements &quot;</span>
            <span class="s2">&quot;but should be exactly 4 - &lt;minx,miny,maxx,maxy&gt;.&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="c1"># check for bounds validity</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nv</span><span class="p">:</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="n">nh</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nh</span><span class="p">,</span> <span class="n">nv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nh</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The &#39;nh&#39; and &#39;nv&#39; parameters (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nh</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
            <span class="s2">&quot;could not be converted to integers.&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="c1"># bounding box line lengths</span>
    <span class="n">len_h</span><span class="p">,</span> <span class="n">len_v</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># horizontal and vertical increments</span>
    <span class="n">incr_h</span><span class="p">,</span> <span class="n">incr_v</span> <span class="o">=</span> <span class="n">len_h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">len_v</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># define the horizontal and vertical space</span>
    <span class="n">space_h</span> <span class="o">=</span> <span class="p">[</span><span class="n">incr_h</span> <span class="o">*</span> <span class="n">slot</span> <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nv</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="n">space_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">incr_v</span> <span class="o">*</span> <span class="n">slot</span> <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nh</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="c1"># create vertical and horizontal lines</span>
    <span class="n">lines_h</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">build_chains</span><span class="p">(</span><span class="n">space_h</span><span class="p">,</span> <span class="n">space_v</span><span class="p">,</span> <span class="n">exterior</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
    <span class="n">lines_v</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">build_chains</span><span class="p">(</span><span class="n">space_h</span><span class="p">,</span> <span class="n">space_v</span><span class="p">,</span> <span class="n">exterior</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># combine into one list</span>
    <span class="n">lattice</span> <span class="o">=</span> <span class="n">lines_h</span> <span class="o">+</span> <span class="n">lines_v</span>

    <span class="k">return</span> <span class="n">lattice</span></div>



<div class="viewcode-block" id="PointPattern">
<a class="viewcode-back" href="../../generated/spaghetti.PointPattern.html#spaghetti.PointPattern">[docs]</a>
<span class="k">class</span> <span class="nc">PointPattern</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A stub point pattern class used to store a point pattern.</span>

<span class="sd">    Note from the original author of ``pysal.network``:</span>
<span class="sd">    This class is monkey patched with network specific attributes when the</span>
<span class="sd">    points are snapped to a network. In the future this class may be</span>
<span class="sd">    replaced with a generic point pattern class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_data : {str, list, tuple, libpysal.cg.Point, geopandas.GeoDataFrame}</span>
<span class="sd">        The input geographic data. Either (1) a path to a shapefile</span>
<span class="sd">        (str); (2) an iterable containing ``libpysal.cg.Point``</span>
<span class="sd">        objects; (3) a single ``libpysal.cg.Point``; or</span>
<span class="sd">        (4) a ``geopandas.GeoDataFrame``.</span>
<span class="sd">    idvariable : str</span>
<span class="sd">        Field in the shapefile to use as an ID variable.</span>
<span class="sd">    attribute :  bool</span>
<span class="sd">        A flag to indicate whether all attributes are tagged to this</span>
<span class="sd">        class (``True``) or excluded (``False``). Default is ``False``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    points : dict</span>
<span class="sd">        Keys are the point IDs (int). Values are the :math:`(x,y)`</span>
<span class="sd">        coordinates (tuple).</span>
<span class="sd">    npoints : int</span>
<span class="sd">        The number of points.</span>
<span class="sd">    obs_to_arc : dict</span>
<span class="sd">        Keys are arc IDs (tuple). Values are snapped point information</span>
<span class="sd">        (``dict``).  Within the snapped point information (``dict``)</span>
<span class="sd">        keys are observation IDs (``int``), and values are snapped</span>
<span class="sd">        coordinates.</span>
<span class="sd">    obs_to_vertex : list</span>
<span class="sd">       List of incident network vertices to snapped observation points</span>
<span class="sd">       converted from a ``default_dict``. Originally in the form of</span>
<span class="sd">       paired left/right nearest network vertices {netvtx1: obs_id1,</span>
<span class="sd">       netvtx2: obs_id1, netvtx1: obs_id2... netvtx1: obs_idn}, then</span>
<span class="sd">       simplified to a list in the form</span>
<span class="sd">       [netvtx1, netvtx2, netvtx1, netvtx2, ...].</span>
<span class="sd">    dist_to_vertex : dict</span>
<span class="sd">        Keys are observations IDs (``int``). Values are distance lookup</span>
<span class="sd">        (``dict``). Within distance lookup (``dict``) keys are the two</span>
<span class="sd">        incident vertices of the arc and values are distance to each of</span>
<span class="sd">        those arcs.</span>
<span class="sd">    snapped_coordinates : dict</span>
<span class="sd">        Keys are the point IDs (int). Values are the snapped :math:`(x,y)`</span>
<span class="sd">        coordinates (tuple).</span>
<span class="sd">    snap_dist : bool</span>
<span class="sd">            Flag as ``True`` to include the distance from the original</span>
<span class="sd">            location to the snapped location along the network. Default</span>
<span class="sd">            is ``False``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PointPattern.__init__">
<a class="viewcode-back" href="../../generated/spaghetti.PointPattern.html#spaghetti.PointPattern.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idvariable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># initialize points dictionary and counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># determine input point data type</span>
        <span class="n">in_dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">in_data</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># flag for points from a shapefile</span>
        <span class="n">from_shp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># flag for points as libpysal.cg.Point objects</span>
        <span class="n">is_libpysal_points</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">supported_iterables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;list&quot;</span><span class="p">,</span> <span class="s2">&quot;tuple&quot;</span><span class="p">]</span>
        <span class="c1"># type error message</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; not supported for point pattern instantiation.&quot;</span>

        <span class="c1"># set appropriate geometries</span>
        <span class="k">if</span> <span class="n">in_dtype</span> <span class="o">==</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span>
            <span class="n">from_shp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">in_dtype</span> <span class="ow">in</span> <span class="n">supported_iterables</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">in_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;libpysal.cg.shapes.Point&quot;</span><span class="p">:</span>
                <span class="n">is_libpysal_points</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">in_dtype</span> <span class="o">==</span> <span class="s2">&quot;libpysal.cg.shapes.Point&quot;</span><span class="p">:</span>
            <span class="n">in_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_data</span><span class="p">]</span>
            <span class="n">is_libpysal_points</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">in_dtype</span> <span class="o">==</span> <span class="s2">&quot;geopandas.geodataframe.GeoDataFrame&quot;</span><span class="p">:</span>
            <span class="n">from_shp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">in_dtype</span><span class="p">)))</span>

        <span class="c1"># either set native point ID from dataset or create new IDs</span>
        <span class="k">if</span> <span class="n">idvariable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_libpysal_points</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">get_ids</span><span class="p">(</span><span class="n">in_data</span><span class="p">,</span> <span class="n">idvariable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># extract the point geometries</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_libpysal_points</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">from_shp</span><span class="p">:</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">_open</span><span class="p">(</span><span class="n">in_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pts_objs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_data</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">cg</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">Point</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pts_objs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">in_data</span>

        <span class="c1"># fetch attributes if requested</span>
        <span class="k">if</span> <span class="n">attribute</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_libpysal_points</span><span class="p">:</span>
            <span class="c1"># open the database file if data is from shapefile</span>
            <span class="k">if</span> <span class="n">from_shp</span><span class="p">:</span>
                <span class="n">dbname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">in_data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.dbf&quot;</span>
                <span class="n">db</span> <span class="o">=</span> <span class="n">_open</span><span class="p">(</span><span class="n">dbname</span><span class="p">)</span>

            <span class="c1"># if data is from a GeoDataFrame, drop the geometry column</span>
            <span class="c1"># and declare attribute values as a list of lists</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">db</span> <span class="o">=</span> <span class="n">in_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">in_data</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">db</span> <span class="o">=</span> <span class="p">[[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">db</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># iterate over all points</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pts</span><span class="p">):</span>
            <span class="c1"># IDs, attributes</span>
            <span class="k">if</span> <span class="n">ids</span> <span class="ow">and</span> <span class="n">db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="n">db</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>

            <span class="c1"># IDs, no attributes</span>
            <span class="k">elif</span> <span class="n">ids</span> <span class="ow">and</span> <span class="n">db</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

            <span class="c1"># no IDs, attributes</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">ids</span> <span class="ow">and</span> <span class="n">db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="n">db</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>

            <span class="c1"># no IDs, no attributes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">pt</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># close the shapefile and database file</span>
        <span class="c1"># if the input data is a .shp</span>
        <span class="k">if</span> <span class="n">from_shp</span><span class="p">:</span>
            <span class="n">pts</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">db</span><span class="p">:</span>
                <span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># record number of points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
</div>



<span class="k">class</span> <span class="nc">SimulatedPointPattern</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Note from the original author of ``pysal.network``:</span>
<span class="sd">    Struct style class to mirror the ``PointPattern`` class.</span>
<span class="sd">    If the ``PointPattern`` class has methods, it might make</span>
<span class="sd">    sense to make this a child of that class. This class is not intended</span>
<span class="sd">    to be used by the external user.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    npoints : int</span>
<span class="sd">        The number of points.</span>
<span class="sd">    obs_to_arc : dict</span>
<span class="sd">        Keys are arc IDs (tuple). Values are snapped point information</span>
<span class="sd">        (dict).  Within the snapped point information (dict)</span>
<span class="sd">        keys are observation IDs (int), and values are snapped</span>
<span class="sd">        coordinates.</span>
<span class="sd">    obs_to_vertex : list</span>
<span class="sd">       List of incident network vertices to snapped observation points</span>
<span class="sd">       converted from a default_dict. Originally in the form of</span>
<span class="sd">       paired left/right nearest network vertices {netvtx1: obs_id1,</span>
<span class="sd">       netvtx2: obs_id1, netvtx1: obs_id2... netvtx1: obs_idn}, then</span>
<span class="sd">       simplified to a list in the form</span>
<span class="sd">       [netvtx1, netvtx2, netvtx1, netvtx2, ...].</span>
<span class="sd">    dist_to_vertex : dict</span>
<span class="sd">        Keys are observations IDs (int). Values are distance lookup</span>
<span class="sd">        (dict). Within distance lookup (dict) keys are the two</span>
<span class="sd">        incident vertices of the arc and values are distance to each of</span>
<span class="sd">        those arcs.</span>
<span class="sd">    snapped_coordinates : dict</span>
<span class="sd">        Keys are the point IDs (int). Values are the snapped :math:`(x,y)`</span>
<span class="sd">        coordinates (tuple).</span>
<span class="sd">    snap_dist : bool</span>
<span class="sd">            Flag as ``True`` to include the distance from the original</span>
<span class="sd">            location to the snapped location along the network. Default</span>
<span class="sd">            is ``False``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># duplicate post-snapping PointPattern class structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs_to_arc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs_to_vertex</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_to_vertex</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapped_coordinates</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2017-, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.3.7.<br/>
    </p>
  </div>
</footer>
  </body>
</html>